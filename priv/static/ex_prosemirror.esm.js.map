{
  "version": 3,
  "sources": ["../../assets/js/ExEditorView.js", "../../assets/js/prosemirror/plugins/placeholder.js", "../../assets/js/prosemirror/schema.js", "../../assets/js/prosemirror/marks/index.js", "../../assets/js/prosemirror/menu.js", "../../assets/node_modules/crelt/index.es.js", "../../assets/node_modules/prosemirror-transform/src/map.js", "../../assets/node_modules/prosemirror-transform/src/transform.js", "../../assets/node_modules/prosemirror-transform/src/step.js", "../../assets/node_modules/prosemirror-transform/src/replace_step.js", "../../assets/node_modules/prosemirror-transform/src/structure.js", "../../assets/node_modules/prosemirror-transform/src/mark_step.js", "../../assets/node_modules/prosemirror-transform/src/mark.js", "../../assets/node_modules/prosemirror-transform/src/replace.js", "../../assets/node_modules/prosemirror-commands/src/commands.js", "../../assets/node_modules/rope-sequence/dist/index.es.js", "../../assets/node_modules/prosemirror-history/src/history.js", "../../assets/node_modules/prosemirror-menu/src/icons.js", "../../assets/node_modules/prosemirror-menu/src/menu.js", "../../assets/node_modules/prosemirror-menu/src/menubar.js", "../../assets/js/prosemirror/icons.js", "../../assets/js/prosemirror/marks/helper.js", "../../assets/js/prosemirror/blocks/index.js", "../../assets/js/prosemirror/blocks/helpers.js", "../../assets/js/hooks/index.js", "../../assets/node_modules/w3c-keyname/index.es.js", "../../assets/node_modules/prosemirror-keymap/src/keymap.js", "../../assets/js/prosemirror/keymaps.js", "../../assets/js/index.js"],
  "sourcesContent": ["import { DOMParser } from 'prosemirror-model';\nimport { EditorState } from 'prosemirror-state';\nimport { EditorView } from 'prosemirror-view';\nimport { insertPlaceholder } from './prosemirror/plugins/placeholder';\nimport schemaFunc from './prosemirror/schema';\n\nexport default class ExEditorView {\n  /**\n   * @param {HTMLElement} editorNode\n   * @param {{ blocks: Object[], marks: Object[], plugins: Object[] }} opts\n   */\n  constructor(editorNode, opts) {\n    this.editorNode = editorNode;\n    this.target = editorNode.dataset.target + '_plain';\n\n    this.editorView = new EditorView(editorNode, {\n      state: this.initializeEditorState(opts),\n      dispatchTransaction: (transaction) => {\n        this.dispatchTransaction(transaction);\n      }\n    });\n\n    this.addListeners();\n  }\n\n  initializeEditorState({ blocks, marks, plugins }) {\n    const opts = {\n      marksSelection: JSON.parse(this.editorNode.dataset.marks),\n      blocksSelection: JSON.parse(this.editorNode.dataset.blocks),\n      inline: JSON.parse(this.editorNode.dataset.inline),\n      blocks,\n      marks\n    };\n\n    const schema = schemaFunc(opts);\n\n    plugins = plugins(schema).map((plugin, index) => {\n      if (plugin.key.startsWith('plugin$')) {\n        plugin.key = 'plugin$' + index;\n      }\n      return plugin;\n    });\n\n    return EditorState.create({\n      doc: this.getDoc(schema),\n      plugins: plugins\n    });\n  }\n\n  getDoc(schema) {\n    const initialValue = document.querySelector(this.target).value;\n\n    if (initialValue.length > 0) {\n      try {\n        return schema.nodeFromJSON(JSON.parse(initialValue));\n      } catch {\n        return DOMParser.fromSchema(schema).parse('');\n      }\n    } else {\n      return DOMParser.fromSchema(schema).parse('');\n    }\n  }\n\n  addListeners() {\n    const exEditorView = this;\n    this.editorNode.addEventListener('exProsemirrorInsertPlaceholder', ({ detail }) => {\n      insertPlaceholder(exEditorView, { nodeType: detail.nodeType });\n    });\n  }\n\n  dispatchTransaction(transaction) {\n    const newState = this.editorView.state.apply(transaction);\n    const parsedState = newState.doc.toJSON();\n\n    // TODO liveview supports\n\n    const input = document.querySelector(this.target);\n    input.value = JSON.stringify(parsedState);\n    input.dispatchEvent(new CustomEvent('change', { detail: JSON.parse(input.value) }));\n\n    this.editorView.updateState(newState);\n  }\n}\n", "import {Plugin} from 'prosemirror-state';\nimport {Decoration, DecorationSet}  from 'prosemirror-view';\n\nexport const placeholderPlugin = new Plugin({\n  state: {\n    init() { return DecorationSet.empty; },\n    apply(tr, set) {\n      // Adjust decoration positions to changes made by the transaction\n      set = set.map(tr.mapping, tr.doc);\n      // See if the transaction adds or removes any placeholders\n      let action = tr.getMeta(this);\n      if (action && action.add) {\n        let widget = document.createElement('placeholder');\n        let deco = Decoration.widget(action.add.pos, widget, {id: action.add.id});\n        set = set.add(tr.doc, [deco]);\n      } else if (action && action.remove) {\n        set = set.remove(\n          set.find(\n            null,\n            null,\n            spec => spec.id == action.remove.id\n          )\n        );\n      }\n\n      return set;\n    }\n  },\n  props: {\n    decorations(state) { return this.getState(state); }\n  }\n});\n\n\nexport function insertPlaceholder(exEditorView, {nodeType}) {\n  // A fresh object to act as the ID for this upload\n  let id = {};\n\n  // Replace the selection with a placeholder\n  let tr = exEditorView.editorView.state.tr;\n  if (!tr.selection.empty) {\n    tr.deleteSelection();\n  }\n\n  exEditorView.editorNode.addEventListener(\n    'replacePlaceholder',\n    function(e){ replacePlaceholder(exEditorView, e); }\n  );\n\n  tr.setMeta(placeholderPlugin, {add: {id, pos: tr.selection.from}});\n  exEditorView.editorView.dispatch(tr);\n\n\n  const msg = {detail: {nodeType: nodeType, id, tr}};\n  exEditorView.editorNode.dispatchEvent(new CustomEvent('insertPlaceholder', msg));\n}\n\nexport function replacePlaceholder(exEditorView, {detail: detail}) {\n  const pos = findPlaceholder(exEditorView.editorView.state, detail.id);\n  // If the content around the placeholder has been deleted, drop\n  // the image\n  if (pos == null) return;\n  // Otherwise, insert it at the placeholder's position, and remove\n  // the placeholder\n\n  dispatchReplace({\n    node: detail.callback(exEditorView.editorView.state.schema.nodes),\n    id: detail.id,\n    pos,\n    exEditorView\n  });\n}\n\nfunction dispatchReplace({exEditorView, id, pos, node}) {\n  // TODO manage error\n  exEditorView.editorView.dispatch(exEditorView.editorView.state.tr\n    .replaceWith(pos, pos, node)\n    .setMeta(placeholderPlugin, {remove: {id}}));\n}\n\nfunction findPlaceholder(state, id) {\n  let decos = placeholderPlugin.getState(state);\n  let found = decos.find(null, null, spec => spec.id == id);\n  return found.length ? found[0].from : null;\n}\n", "import { Schema } from 'prosemirror-model';\nimport { generateSchemaMarks } from './marks';\nimport { generateSchemablocks } from './blocks';\n\n/**\n * @param {{blocks: Object[], marks: Object[], blocksSelection: JSON, marksSelection: JSON, inline: Boolean}} options\n */\nexport default (options) => (\n  new Schema({\n    nodes: generateSchemablocks(options),\n    marks: generateSchemaMarks(options)\n  })\n);\n", "import { marks as prosemirrorMarks } from 'prosemirror-schema-basic';\nimport { generateMarkItem, generateColorsMenu, generateFontFamilyMenu } from '../menu';\nimport { generateExProsemirrorMarks } from './helper';\n\nexport const marks = {\n  strong: { ...prosemirrorMarks.strong, generateMenuItem: generateMarkItem('strong') },\n  em: { ...prosemirrorMarks.em, generateMenuItem: generateMarkItem('em') },\n  link: { ...prosemirrorMarks.link },\n  strikethrough: {\n    toDOM() {return ['del', 0];},\n    parseDOM: [{ tag: 'del' }],\n    generateMenuItem: generateMarkItem('strikethrough')\n  },\n  underline: {\n    toDOM() {\n      return ['span', { style: 'text-decoration: underline' }, 0];\n    },\n    parseDOM: [{ tag: 'span' }],\n    generateMenuItem: generateMarkItem('underline')\n  },\n  color: {\n    title: 'Color',\n    label: 'Color',\n    attrs: {color: {}},\n    toDOM(node) {\n      return ['span', {style: 'color: ' + node.attrs.color}, 0];\n    },\n    parseDOM: [{ tag: 'span', getAttrs(dom) {\n      return {\n        color: dom.style.color,\n      };\n    }}],\n    generateMenuItem: generateColorsMenu\n  },\n  font_family: {\n    title: 'Font',\n    label: 'Font',\n    attrs: {font_family: {}},\n    toDOM(node) {\n      return ['span', {style: 'font-family: ' + node.attrs.font_family}, 0];\n    },\n    parseDOM: [{ tag: 'span', getAttrs(dom) {\n      return {\n        font_family: dom.style['font-family'],\n      };\n    }}],\n    generateMenuItem: generateFontFamilyMenu\n  }\n};\n\n/**\n * Returns a function that will generate Marks for Prosemirror schema.\n */\nexport const generateSchemaMarks = ({ marksSelection, marks }) => (\n  generateExProsemirrorMarks(marksSelection, marks)\n);\n", "import { MenuItem, blockTypeItem, Dropdown } from 'prosemirror-menu';\nimport { icons } from './icons';\nimport { toggleMark } from 'prosemirror-commands';\nimport { toggleMultiMarks } from './marks/helper';\n\nfunction getTitle({name: name, spec: {title}}) {\n  return (title || name);\n}\n\nexport const generateHeadingItem = (schema) => {\n  if(schema.nodes.heading) {\n    return schema.nodes.heading.spec.config.values.map((heading) => {\n      return blockTypeItem(schema.nodes.heading, {\n        title: 'Header ' + heading,\n        label: 'Header ' + heading,\n        attrs: {level: heading}\n      });\n    });\n  } else {\n    return [];\n  }\n};\n\nexport const generateParagraphItem = (schema) => {\n  if(schema.nodes.paragraph) {\n    return [blockTypeItem(schema.nodes.paragraph, {\n      title: 'paragraph',\n      label: 'paragraph'\n    })];\n  }\n\n  return [];\n};\n\nexport const generateHTMLItem = (schema) => {\n  if(schema.nodes.html) {\n    return [\n      new MenuItem({\n        title: 'Insert HTML code',\n        label: 'HTML',\n        enable() { return true; },\n        run(_state, _transaction, view) {\n          const exEditorNode = view.dom.parentNode.parentNode;\n          exEditorNode.dispatchEvent(new CustomEvent('exProsemirrorInsertPlaceholder', {detail: {nodeType: 'html'}}));\n        }\n      })\n    ];\n  }\n\n  return [];\n};\n\n\nexport const generateMediaMenu = (schema) => {\n  if (!schema.nodes.image) {\n    return [];\n  }\n\n  return [\n    new MenuItem({\n      title: 'Insert image',\n      label: 'Image',\n      enable() { return true; },\n      run(_state, _transaction, view) {\n        const exEditorNode = view.dom.parentNode.parentNode;\n        exEditorNode.dispatchEvent(new CustomEvent('exProsemirrorInsertPlaceholder', {detail: {nodeType: 'image'}}));\n      }\n    })\n  ];\n};\n\nexport const generateMarkItem = (type) => {\n  return (schema) => {\n    if (!schema.marks[type]) {\n      return [];\n    }\n\n    const markElement = schema.marks[type];\n    const icon = markElement.spec.icon || icons[type];\n    return [markItem(schema.marks[type], { title: getTitle(markElement), icon })];\n  };\n};\n\n/**\n * Generate a MenuItem for a schema's mark.\n *\n * @param {any} markType - Type of mark to generate\n * @param {Object} options\n */\nexport function markItem(markType, options) {\n  let passedOptions = {\n    active(state) {\n      return markActive(state, markType);\n    },\n    enable: true\n  };\n\n  for (let prop in options) passedOptions[prop] = options[prop];\n\n  return cmdItem(toggleMark(markType), passedOptions);\n}\n\n\n/**\n * Execute a ProsemirrorCommand\n *\n * @param {any} cmd - command to execute\n * @param {Object} options\n */\nexport function cmdItem(cmd, options) {\n  let passedOptions = {\n    label: options.title,\n    run: cmd\n  };\n  for (let prop in options) passedOptions[prop] = options[prop];\n  if ((!options.enable || options.enable === true) && !options.select)\n    passedOptions[options.enable ? 'enable' : 'select'] = (state) => cmd(state);\n\n  return new MenuItem(passedOptions);\n}\n\n/**\n * Define if a mark is active or not.\n *\n * @param {EditorState} state\n * @param {any} type - Mark's type\n */\nexport function markActive(state, type) {\n  let { from, $from, to, empty } = state.selection;\n  if (empty) return type.isInSet(state.storedMarks || $from.marks());\n  else return state.doc.rangeHasMark(from, to, type);\n}\n\nexport const generateColorsMenu = (schema) => {\n  const items = generateMultiMarkItem(schema, 'color');\n  return [new Dropdown(items, {label: 'Color'})];\n};\n\nexport const generateFontFamilyMenu = (schema) => {\n  const items = generateMultiMarkItem(schema, 'font_family');\n  return [new Dropdown(items, {label: 'Font'})];\n};\n\nexport const generateMultiMarkItem = (schema, markType) => {\n  if (!schema.marks[markType]) {\n    return [];\n  }\n\n  const results = [multiMarkItem(schema.marks[markType], {title: 'default'})];\n  const values = schema.marks[markType].spec.config.values;\n\n  if (Array.isArray(values)) {\n    for (const value of values) {\n      const attrs = [];\n      attrs[markType] = value;\n      results.push(multiMarkItem(schema.marks[markType], { title: value }, attrs));\n    }\n  } else {\n    for (const [name, value] of Object.entries(values)) {\n      const attrs = [];\n      attrs[markType] = value;\n      results.push(multiMarkItem(schema.marks[markType], { title: name }, attrs));\n    }\n  }\n\n  return results;\n};\n\nexport function multiMarkItem(markType, options, attrs) {\n  return cmdItem(toggleMultiMarks(markType, attrs), {enable: true, ...options});\n}\n\n\nexport const menuHelper = { generateParagraphItem, generateHeadingItem, generateHTMLItem, generateMediaMenu };\n", "export default function crelt() {\n  var elt = arguments[0]\n  if (typeof elt == \"string\") elt = document.createElement(elt)\n  var i = 1, next = arguments[1]\n  if (next && typeof next == \"object\" && next.nodeType == null && !Array.isArray(next)) {\n    for (var name in next) if (Object.prototype.hasOwnProperty.call(next, name)) {\n      var value = next[name]\n      if (typeof value == \"string\") elt.setAttribute(name, value)\n      else if (value != null) elt[name] = value\n    }\n    i++\n  }\n  for (; i < arguments.length; i++) add(elt, arguments[i])\n  return elt\n}\n\nfunction add(elt, child) {\n  if (typeof child == \"string\") {\n    elt.appendChild(document.createTextNode(child))\n  } else if (child == null) {\n  } else if (child.nodeType != null) {\n    elt.appendChild(child)\n  } else if (Array.isArray(child)) {\n    for (var i = 0; i < child.length; i++) add(elt, child[i])\n  } else {\n    throw new RangeError(\"Unsupported child node: \" + child)\n  }\n}\n", "// Mappable:: interface\n// There are several things that positions can be mapped through.\n// Such objects conform to this interface.\n//\n//   map:: (pos: number, assoc: ?number) \u2192 number\n//   Map a position through this object. When given, `assoc` (should\n//   be -1 or 1, defaults to 1) determines with which side the\n//   position is associated, which determines in which direction to\n//   move when a chunk of content is inserted at the mapped position.\n//\n//   mapResult:: (pos: number, assoc: ?number) \u2192 MapResult\n//   Map a position, and return an object containing additional\n//   information about the mapping. The result's `deleted` field tells\n//   you whether the position was deleted (completely enclosed in a\n//   replaced range) during the mapping. When content on only one side\n//   is deleted, the position itself is only considered deleted when\n//   `assoc` points in the direction of the deleted content.\n\n// Recovery values encode a range index and an offset. They are\n// represented as numbers, because tons of them will be created when\n// mapping, for example, a large number of decorations. The number's\n// lower 16 bits provide the index, the remaining bits the offset.\n//\n// Note: We intentionally don't use bit shift operators to en- and\n// decode these, since those clip to 32 bits, which we might in rare\n// cases want to overflow. A 64-bit float can represent 48-bit\n// integers precisely.\n\nconst lower16 = 0xffff\nconst factor16 = Math.pow(2, 16)\n\nfunction makeRecover(index, offset) { return index + offset * factor16 }\nfunction recoverIndex(value) { return value & lower16 }\nfunction recoverOffset(value) { return (value - (value & lower16)) / factor16 }\n\n// ::- An object representing a mapped position with extra\n// information.\nexport class MapResult {\n  constructor(pos, deleted = false, recover = null) {\n    // :: number The mapped version of the position.\n    this.pos = pos\n    // :: bool Tells you whether the position was deleted, that is,\n    // whether the step removed its surroundings from the document.\n    this.deleted = deleted\n    this.recover = recover\n  }\n}\n\n// :: class extends Mappable\n// A map describing the deletions and insertions made by a step, which\n// can be used to find the correspondence between positions in the\n// pre-step version of a document and the same position in the\n// post-step version.\nexport class StepMap {\n  // :: ([number])\n  // Create a position map. The modifications to the document are\n  // represented as an array of numbers, in which each group of three\n  // represents a modified chunk as `[start, oldSize, newSize]`.\n  constructor(ranges, inverted = false) {\n    if (!ranges.length && StepMap.empty) return StepMap.empty\n    this.ranges = ranges\n    this.inverted = inverted\n  }\n\n  recover(value) {\n    let diff = 0, index = recoverIndex(value)\n    if (!this.inverted) for (let i = 0; i < index; i++)\n      diff += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1]\n    return this.ranges[index * 3] + diff + recoverOffset(value)\n  }\n\n  // : (number, ?number) \u2192 MapResult\n  mapResult(pos, assoc = 1) { return this._map(pos, assoc, false) }\n\n  // : (number, ?number) \u2192 number\n  map(pos, assoc = 1) { return this._map(pos, assoc, true) }\n\n  _map(pos, assoc, simple) {\n    let diff = 0, oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2\n    for (let i = 0; i < this.ranges.length; i += 3) {\n      let start = this.ranges[i] - (this.inverted ? diff : 0)\n      if (start > pos) break\n      let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex], end = start + oldSize\n      if (pos <= end) {\n        let side = !oldSize ? assoc : pos == start ? -1 : pos == end ? 1 : assoc\n        let result = start + diff + (side < 0 ? 0 : newSize)\n        if (simple) return result\n        let recover = pos == (assoc < 0 ? start : end) ? null : makeRecover(i / 3, pos - start)\n        return new MapResult(result, assoc < 0 ? pos != start : pos != end, recover)\n      }\n      diff += newSize - oldSize\n    }\n    return simple ? pos + diff : new MapResult(pos + diff)\n  }\n\n  touches(pos, recover) {\n    let diff = 0, index = recoverIndex(recover)\n    let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2\n    for (let i = 0; i < this.ranges.length; i += 3) {\n      let start = this.ranges[i] - (this.inverted ? diff : 0)\n      if (start > pos) break\n      let oldSize = this.ranges[i + oldIndex], end = start + oldSize\n      if (pos <= end && i == index * 3) return true\n      diff += this.ranges[i + newIndex] - oldSize\n    }\n    return false\n  }\n\n  // :: ((oldStart: number, oldEnd: number, newStart: number, newEnd: number))\n  // Calls the given function on each of the changed ranges included in\n  // this map.\n  forEach(f) {\n    let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2\n    for (let i = 0, diff = 0; i < this.ranges.length; i += 3) {\n      let start = this.ranges[i], oldStart = start - (this.inverted ? diff : 0), newStart = start + (this.inverted ? 0 : diff)\n      let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex]\n      f(oldStart, oldStart + oldSize, newStart, newStart + newSize)\n      diff += newSize - oldSize\n    }\n  }\n\n  // :: () \u2192 StepMap\n  // Create an inverted version of this map. The result can be used to\n  // map positions in the post-step document to the pre-step document.\n  invert() {\n    return new StepMap(this.ranges, !this.inverted)\n  }\n\n  toString() {\n    return (this.inverted ? \"-\" : \"\") + JSON.stringify(this.ranges)\n  }\n\n  // :: (n: number) \u2192 StepMap\n  // Create a map that moves all positions by offset `n` (which may be\n  // negative). This can be useful when applying steps meant for a\n  // sub-document to a larger document, or vice-versa.\n  static offset(n) {\n    return n == 0 ? StepMap.empty : new StepMap(n < 0 ? [0, -n, 0] : [0, 0, n])\n  }\n}\n\n// :: StepMap\n// A StepMap that contains no changed ranges.\nStepMap.empty = new StepMap([])\n\n// :: class extends Mappable\n// A mapping represents a pipeline of zero or more [step\n// maps](#transform.StepMap). It has special provisions for losslessly\n// handling mapping positions through a series of steps in which some\n// steps are inverted versions of earlier steps. (This comes up when\n// \u2018[rebasing](/docs/guide/#transform.rebasing)\u2019 steps for\n// collaboration or history management.)\nexport class Mapping {\n  // :: (?[StepMap])\n  // Create a new mapping with the given position maps.\n  constructor(maps, mirror, from, to) {\n    // :: [StepMap]\n    // The step maps in this mapping.\n    this.maps = maps || []\n    // :: number\n    // The starting position in the `maps` array, used when `map` or\n    // `mapResult` is called.\n    this.from = from || 0\n    // :: number\n    // The end position in the `maps` array.\n    this.to = to == null ? this.maps.length : to\n    this.mirror = mirror\n  }\n\n  // :: (?number, ?number) \u2192 Mapping\n  // Create a mapping that maps only through a part of this one.\n  slice(from = 0, to = this.maps.length) {\n    return new Mapping(this.maps, this.mirror, from, to)\n  }\n\n  copy() {\n    return new Mapping(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to)\n  }\n\n  // :: (StepMap, ?number)\n  // Add a step map to the end of this mapping. If `mirrors` is\n  // given, it should be the index of the step map that is the mirror\n  // image of this one.\n  appendMap(map, mirrors) {\n    this.to = this.maps.push(map)\n    if (mirrors != null) this.setMirror(this.maps.length - 1, mirrors)\n  }\n\n  // :: (Mapping)\n  // Add all the step maps in a given mapping to this one (preserving\n  // mirroring information).\n  appendMapping(mapping) {\n    for (let i = 0, startSize = this.maps.length; i < mapping.maps.length; i++) {\n      let mirr = mapping.getMirror(i)\n      this.appendMap(mapping.maps[i], mirr != null && mirr < i ? startSize + mirr : null)\n    }\n  }\n\n  // :: (number) \u2192 ?number\n  // Finds the offset of the step map that mirrors the map at the\n  // given offset, in this mapping (as per the second argument to\n  // `appendMap`).\n  getMirror(n) {\n    if (this.mirror) for (let i = 0; i < this.mirror.length; i++)\n      if (this.mirror[i] == n) return this.mirror[i + (i % 2 ? -1 : 1)]\n  }\n\n  setMirror(n, m) {\n    if (!this.mirror) this.mirror = []\n    this.mirror.push(n, m)\n  }\n\n  // :: (Mapping)\n  // Append the inverse of the given mapping to this one.\n  appendMappingInverted(mapping) {\n    for (let i = mapping.maps.length - 1, totalSize = this.maps.length + mapping.maps.length; i >= 0; i--) {\n      let mirr = mapping.getMirror(i)\n      this.appendMap(mapping.maps[i].invert(), mirr != null && mirr > i ? totalSize - mirr - 1 : null)\n    }\n  }\n\n  // :: () \u2192 Mapping\n  // Create an inverted version of this mapping.\n  invert() {\n    let inverse = new Mapping\n    inverse.appendMappingInverted(this)\n    return inverse\n  }\n\n  // : (number, ?number) \u2192 number\n  // Map a position through this mapping.\n  map(pos, assoc = 1) {\n    if (this.mirror) return this._map(pos, assoc, true)\n    for (let i = this.from; i < this.to; i++)\n      pos = this.maps[i].map(pos, assoc)\n    return pos\n  }\n\n  // : (number, ?number) \u2192 MapResult\n  // Map a position through this mapping, returning a mapping\n  // result.\n  mapResult(pos, assoc = 1) { return this._map(pos, assoc, false) }\n\n  _map(pos, assoc, simple) {\n    let deleted = false\n\n    for (let i = this.from; i < this.to; i++) {\n      let map = this.maps[i], result = map.mapResult(pos, assoc)\n      if (result.recover != null) {\n        let corr = this.getMirror(i)\n        if (corr != null && corr > i && corr < this.to) {\n          i = corr\n          pos = this.maps[corr].recover(result.recover)\n          continue\n        }\n      }\n\n      if (result.deleted) deleted = true\n      pos = result.pos\n    }\n\n    return simple ? pos : new MapResult(pos, deleted)\n  }\n}\n", "import {Mapping} from \"./map\"\n\nexport function TransformError(message) {\n  let err = Error.call(this, message)\n  err.__proto__ = TransformError.prototype\n  return err\n}\n\nTransformError.prototype = Object.create(Error.prototype)\nTransformError.prototype.constructor = TransformError\nTransformError.prototype.name = \"TransformError\"\n\n// ::- Abstraction to build up and track an array of\n// [steps](#transform.Step) representing a document transformation.\n//\n// Most transforming methods return the `Transform` object itself, so\n// that they can be chained.\nexport class Transform {\n  // :: (Node)\n  // Create a transform that starts with the given document.\n  constructor(doc) {\n    // :: Node\n    // The current document (the result of applying the steps in the\n    // transform).\n    this.doc = doc\n    // :: [Step]\n    // The steps in this transform.\n    this.steps = []\n    // :: [Node]\n    // The documents before each of the steps.\n    this.docs = []\n    // :: Mapping\n    // A mapping with the maps for each of the steps in this transform.\n    this.mapping = new Mapping\n  }\n\n  // :: Node The starting document.\n  get before() { return this.docs.length ? this.docs[0] : this.doc }\n\n  // :: (step: Step) \u2192 this\n  // Apply a new step in this transform, saving the result. Throws an\n  // error when the step fails.\n  step(object) {\n    let result = this.maybeStep(object)\n    if (result.failed) throw new TransformError(result.failed)\n    return this\n  }\n\n  // :: (Step) \u2192 StepResult\n  // Try to apply a step in this transformation, ignoring it if it\n  // fails. Returns the step result.\n  maybeStep(step) {\n    let result = step.apply(this.doc)\n    if (!result.failed) this.addStep(step, result.doc)\n    return result\n  }\n\n  // :: bool\n  // True when the document has been changed (when there are any\n  // steps).\n  get docChanged() {\n    return this.steps.length > 0\n  }\n\n  addStep(step, doc) {\n    this.docs.push(this.doc)\n    this.steps.push(step)\n    this.mapping.appendMap(step.getMap())\n    this.doc = doc\n  }\n}\n", "import {ReplaceError} from \"prosemirror-model\"\n\nimport {StepMap} from \"./map\"\n\nfunction mustOverride() { throw new Error(\"Override me\") }\n\nconst stepsByID = Object.create(null)\n\n// ::- A step object represents an atomic change. It generally applies\n// only to the document it was created for, since the positions\n// stored in it will only make sense for that document.\n//\n// New steps are defined by creating classes that extend `Step`,\n// overriding the `apply`, `invert`, `map`, `getMap` and `fromJSON`\n// methods, and registering your class with a unique\n// JSON-serialization identifier using\n// [`Step.jsonID`](#transform.Step^jsonID).\nexport class Step {\n  // :: (doc: Node) \u2192 StepResult\n  // Applies this step to the given document, returning a result\n  // object that either indicates failure, if the step can not be\n  // applied to this document, or indicates success by containing a\n  // transformed document.\n  apply(_doc) { return mustOverride() }\n\n  // :: () \u2192 StepMap\n  // Get the step map that represents the changes made by this step,\n  // and which can be used to transform between positions in the old\n  // and the new document.\n  getMap() { return StepMap.empty }\n\n  // :: (doc: Node) \u2192 Step\n  // Create an inverted version of this step. Needs the document as it\n  // was before the step as argument.\n  invert(_doc) { return mustOverride() }\n\n  // :: (mapping: Mappable) \u2192 ?Step\n  // Map this step through a mappable thing, returning either a\n  // version of that step with its positions adjusted, or `null` if\n  // the step was entirely deleted by the mapping.\n  map(_mapping) { return mustOverride() }\n\n  // :: (other: Step) \u2192 ?Step\n  // Try to merge this step with another one, to be applied directly\n  // after it. Returns the merged step when possible, null if the\n  // steps can't be merged.\n  merge(_other) { return null }\n\n  // :: () \u2192 Object\n  // Create a JSON-serializeable representation of this step. When\n  // defining this for a custom subclass, make sure the result object\n  // includes the step type's [JSON id](#transform.Step^jsonID) under\n  // the `stepType` property.\n  toJSON() { return mustOverride() }\n\n  // :: (Schema, Object) \u2192 Step\n  // Deserialize a step from its JSON representation. Will call\n  // through to the step class' own implementation of this method.\n  static fromJSON(schema, json) {\n    if (!json || !json.stepType) throw new RangeError(\"Invalid input for Step.fromJSON\")\n    let type = stepsByID[json.stepType]\n    if (!type) throw new RangeError(`No step type ${json.stepType} defined`)\n    return type.fromJSON(schema, json)\n  }\n\n  // :: (string, constructor<Step>)\n  // To be able to serialize steps to JSON, each step needs a string\n  // ID to attach to its JSON representation. Use this method to\n  // register an ID for your step classes. Try to pick something\n  // that's unlikely to clash with steps from other modules.\n  static jsonID(id, stepClass) {\n    if (id in stepsByID) throw new RangeError(\"Duplicate use of step JSON ID \" + id)\n    stepsByID[id] = stepClass\n    stepClass.prototype.jsonID = id\n    return stepClass\n  }\n}\n\n// ::- The result of [applying](#transform.Step.apply) a step. Contains either a\n// new document or a failure value.\nexport class StepResult {\n  // : (?Node, ?string)\n  constructor(doc, failed) {\n    // :: ?Node The transformed document.\n    this.doc = doc\n    // :: ?string Text providing information about a failed step.\n    this.failed = failed\n  }\n\n  // :: (Node) \u2192 StepResult\n  // Create a successful step result.\n  static ok(doc) { return new StepResult(doc, null) }\n\n  // :: (string) \u2192 StepResult\n  // Create a failed step result.\n  static fail(message) { return new StepResult(null, message) }\n\n  // :: (Node, number, number, Slice) \u2192 StepResult\n  // Call [`Node.replace`](#model.Node.replace) with the given\n  // arguments. Create a successful result if it succeeds, and a\n  // failed one if it throws a `ReplaceError`.\n  static fromReplace(doc, from, to, slice) {\n    try {\n      return StepResult.ok(doc.replace(from, to, slice))\n    } catch (e) {\n      if (e instanceof ReplaceError) return StepResult.fail(e.message)\n      throw e\n    }\n  }\n}\n", "import {Slice} from \"prosemirror-model\"\n\nimport {Step, StepResult} from \"./step\"\nimport {StepMap} from \"./map\"\n\n// ::- Replace a part of the document with a slice of new content.\nexport class ReplaceStep extends Step {\n  // :: (number, number, Slice, ?bool)\n  // The given `slice` should fit the 'gap' between `from` and\n  // `to`\u2014the depths must line up, and the surrounding nodes must be\n  // able to be joined with the open sides of the slice. When\n  // `structure` is true, the step will fail if the content between\n  // from and to is not just a sequence of closing and then opening\n  // tokens (this is to guard against rebased replace steps\n  // overwriting something they weren't supposed to).\n  constructor(from, to, slice, structure) {\n    super()\n    // :: number\n    // The start position of the replaced range.\n    this.from = from\n    // :: number\n    // The end position of the replaced range.\n    this.to = to\n    // :: Slice\n    // The slice to insert.\n    this.slice = slice\n    this.structure = !!structure\n  }\n\n  apply(doc) {\n    if (this.structure && contentBetween(doc, this.from, this.to))\n      return StepResult.fail(\"Structure replace would overwrite content\")\n    return StepResult.fromReplace(doc, this.from, this.to, this.slice)\n  }\n\n  getMap() {\n    return new StepMap([this.from, this.to - this.from, this.slice.size])\n  }\n\n  invert(doc) {\n    return new ReplaceStep(this.from, this.from + this.slice.size, doc.slice(this.from, this.to))\n  }\n\n  map(mapping) {\n    let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1)\n    if (from.deleted && to.deleted) return null\n    return new ReplaceStep(from.pos, Math.max(from.pos, to.pos), this.slice)\n  }\n\n  merge(other) {\n    if (!(other instanceof ReplaceStep) || other.structure || this.structure) return null\n\n    if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {\n      let slice = this.slice.size + other.slice.size == 0 ? Slice.empty\n          : new Slice(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd)\n      return new ReplaceStep(this.from, this.to + (other.to - other.from), slice, this.structure)\n    } else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {\n      let slice = this.slice.size + other.slice.size == 0 ? Slice.empty\n          : new Slice(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd)\n      return new ReplaceStep(other.from, this.to, slice, this.structure)\n    } else {\n      return null\n    }\n  }\n\n  toJSON() {\n    let json = {stepType: \"replace\", from: this.from, to: this.to}\n    if (this.slice.size) json.slice = this.slice.toJSON()\n    if (this.structure) json.structure = true\n    return json\n  }\n\n  static fromJSON(schema, json) {\n    if (typeof json.from != \"number\" || typeof json.to != \"number\")\n      throw new RangeError(\"Invalid input for ReplaceStep.fromJSON\")\n    return new ReplaceStep(json.from, json.to, Slice.fromJSON(schema, json.slice), !!json.structure)\n  }\n}\n\nStep.jsonID(\"replace\", ReplaceStep)\n\n// ::- Replace a part of the document with a slice of content, but\n// preserve a range of the replaced content by moving it into the\n// slice.\nexport class ReplaceAroundStep extends Step {\n  // :: (number, number, number, number, Slice, number, ?bool)\n  // Create a replace-around step with the given range and gap.\n  // `insert` should be the point in the slice into which the content\n  // of the gap should be moved. `structure` has the same meaning as\n  // it has in the [`ReplaceStep`](#transform.ReplaceStep) class.\n  constructor(from, to, gapFrom, gapTo, slice, insert, structure) {\n    super()\n    // :: number\n    // The start position of the replaced range.\n    this.from = from\n    // :: number\n    // The end position of the replaced range.\n    this.to = to\n    // :: number\n    // The start of preserved range.\n    this.gapFrom = gapFrom\n    // :: number\n    // The end of preserved range.\n    this.gapTo = gapTo\n    // :: Slice\n    // The slice to insert.\n    this.slice = slice\n    // :: number\n    // The position in the slice where the preserved range should be\n    // inserted.\n    this.insert = insert\n    this.structure = !!structure\n  }\n\n  apply(doc) {\n    if (this.structure && (contentBetween(doc, this.from, this.gapFrom) ||\n                           contentBetween(doc, this.gapTo, this.to)))\n      return StepResult.fail(\"Structure gap-replace would overwrite content\")\n\n    let gap = doc.slice(this.gapFrom, this.gapTo)\n    if (gap.openStart || gap.openEnd)\n      return StepResult.fail(\"Gap is not a flat range\")\n    let inserted = this.slice.insertAt(this.insert, gap.content)\n    if (!inserted) return StepResult.fail(\"Content does not fit in gap\")\n    return StepResult.fromReplace(doc, this.from, this.to, inserted)\n  }\n\n  getMap() {\n    return new StepMap([this.from, this.gapFrom - this.from, this.insert,\n                        this.gapTo, this.to - this.gapTo, this.slice.size - this.insert])\n  }\n\n  invert(doc) {\n    let gap = this.gapTo - this.gapFrom\n    return new ReplaceAroundStep(this.from, this.from + this.slice.size + gap,\n                                 this.from + this.insert, this.from + this.insert + gap,\n                                 doc.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from),\n                                 this.gapFrom - this.from, this.structure)\n  }\n\n  map(mapping) {\n    let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1)\n    let gapFrom = mapping.map(this.gapFrom, -1), gapTo = mapping.map(this.gapTo, 1)\n    if ((from.deleted && to.deleted) || gapFrom < from.pos || gapTo > to.pos) return null\n    return new ReplaceAroundStep(from.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure)\n  }\n\n  toJSON() {\n    let json = {stepType: \"replaceAround\", from: this.from, to: this.to,\n                gapFrom: this.gapFrom, gapTo: this.gapTo, insert: this.insert}\n    if (this.slice.size) json.slice = this.slice.toJSON()\n    if (this.structure) json.structure = true\n    return json\n  }\n\n  static fromJSON(schema, json) {\n    if (typeof json.from != \"number\" || typeof json.to != \"number\" ||\n        typeof json.gapFrom != \"number\" || typeof json.gapTo != \"number\" || typeof json.insert != \"number\")\n      throw new RangeError(\"Invalid input for ReplaceAroundStep.fromJSON\")\n    return new ReplaceAroundStep(json.from, json.to, json.gapFrom, json.gapTo,\n                                 Slice.fromJSON(schema, json.slice), json.insert, !!json.structure)\n  }\n}\n\nStep.jsonID(\"replaceAround\", ReplaceAroundStep)\n\nfunction contentBetween(doc, from, to) {\n  let $from = doc.resolve(from), dist = to - from, depth = $from.depth\n  while (dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {\n    depth--\n    dist--\n  }\n  if (dist > 0) {\n    let next = $from.node(depth).maybeChild($from.indexAfter(depth))\n    while (dist > 0) {\n      if (!next || next.isLeaf) return true\n      next = next.firstChild\n      dist--\n    }\n  }\n  return false\n}\n", "import {Slice, Fragment} from \"prosemirror-model\"\n\nimport {Transform} from \"./transform\"\nimport {ReplaceStep, ReplaceAroundStep} from \"./replace_step\"\n\nfunction canCut(node, start, end) {\n  return (start == 0 || node.canReplace(start, node.childCount)) &&\n    (end == node.childCount || node.canReplace(0, end))\n}\n\n// :: (NodeRange) \u2192 ?number\n// Try to find a target depth to which the content in the given range\n// can be lifted. Will not go across\n// [isolating](#model.NodeSpec.isolating) parent nodes.\nexport function liftTarget(range) {\n  let parent = range.parent\n  let content = parent.content.cutByIndex(range.startIndex, range.endIndex)\n  for (let depth = range.depth;; --depth) {\n    let node = range.$from.node(depth)\n    let index = range.$from.index(depth), endIndex = range.$to.indexAfter(depth)\n    if (depth < range.depth && node.canReplace(index, endIndex, content))\n      return depth\n    if (depth == 0 || node.type.spec.isolating || !canCut(node, index, endIndex)) break\n  }\n}\n\n// :: (NodeRange, number) \u2192 this\n// Split the content in the given range off from its parent, if there\n// is sibling content before or after it, and move it up the tree to\n// the depth specified by `target`. You'll probably want to use\n// [`liftTarget`](#transform.liftTarget) to compute `target`, to make\n// sure the lift is valid.\nTransform.prototype.lift = function(range, target) {\n  let {$from, $to, depth} = range\n\n  let gapStart = $from.before(depth + 1), gapEnd = $to.after(depth + 1)\n  let start = gapStart, end = gapEnd\n\n  let before = Fragment.empty, openStart = 0\n  for (let d = depth, splitting = false; d > target; d--)\n    if (splitting || $from.index(d) > 0) {\n      splitting = true\n      before = Fragment.from($from.node(d).copy(before))\n      openStart++\n    } else {\n      start--\n    }\n  let after = Fragment.empty, openEnd = 0\n  for (let d = depth, splitting = false; d > target; d--)\n    if (splitting || $to.after(d + 1) < $to.end(d)) {\n      splitting = true\n      after = Fragment.from($to.node(d).copy(after))\n      openEnd++\n    } else {\n      end++\n    }\n\n  return this.step(new ReplaceAroundStep(start, end, gapStart, gapEnd,\n                                         new Slice(before.append(after), openStart, openEnd),\n                                         before.size - openStart, true))\n}\n\n// :: (NodeRange, NodeType, ?Object, ?NodeRange) \u2192 ?[{type: NodeType, attrs: ?Object}]\n// Try to find a valid way to wrap the content in the given range in a\n// node of the given type. May introduce extra nodes around and inside\n// the wrapper node, if necessary. Returns null if no valid wrapping\n// could be found. When `innerRange` is given, that range's content is\n// used as the content to fit into the wrapping, instead of the\n// content of `range`.\nexport function findWrapping(range, nodeType, attrs, innerRange = range) {\n  let around = findWrappingOutside(range, nodeType)\n  let inner = around && findWrappingInside(innerRange, nodeType)\n  if (!inner) return null\n  return around.map(withAttrs).concat({type: nodeType, attrs}).concat(inner.map(withAttrs))\n}\n\nfunction withAttrs(type) { return {type, attrs: null} }\n\nfunction findWrappingOutside(range, type) {\n  let {parent, startIndex, endIndex} = range\n  let around = parent.contentMatchAt(startIndex).findWrapping(type)\n  if (!around) return null\n  let outer = around.length ? around[0] : type\n  return parent.canReplaceWith(startIndex, endIndex, outer) ? around : null\n}\n\nfunction findWrappingInside(range, type) {\n  let {parent, startIndex, endIndex} = range\n  let inner = parent.child(startIndex)\n  let inside = type.contentMatch.findWrapping(inner.type)\n  if (!inside) return null\n  let lastType = inside.length ? inside[inside.length - 1] : type\n  let innerMatch = lastType.contentMatch\n  for (let i = startIndex; innerMatch && i < endIndex; i++)\n    innerMatch = innerMatch.matchType(parent.child(i).type)\n  if (!innerMatch || !innerMatch.validEnd) return null\n  return inside\n}\n\n// :: (NodeRange, [{type: NodeType, attrs: ?Object}]) \u2192 this\n// Wrap the given [range](#model.NodeRange) in the given set of wrappers.\n// The wrappers are assumed to be valid in this position, and should\n// probably be computed with [`findWrapping`](#transform.findWrapping).\nTransform.prototype.wrap = function(range, wrappers) {\n  let content = Fragment.empty\n  for (let i = wrappers.length - 1; i >= 0; i--) {\n    if (content.size) {\n      let match = wrappers[i].type.contentMatch.matchFragment(content)\n      if (!match || !match.validEnd)\n        throw new RangeError(\"Wrapper type given to Transform.wrap does not form valid content of its parent wrapper\")\n    }\n    content = Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content))\n  }\n\n  let start = range.start, end = range.end\n  return this.step(new ReplaceAroundStep(start, end, start, end, new Slice(content, 0, 0), wrappers.length, true))\n}\n\n// :: (number, ?number, NodeType, ?Object) \u2192 this\n// Set the type of all textblocks (partly) between `from` and `to` to\n// the given node type with the given attributes.\nTransform.prototype.setBlockType = function(from, to = from, type, attrs) {\n  if (!type.isTextblock) throw new RangeError(\"Type given to setBlockType should be a textblock\")\n  let mapFrom = this.steps.length\n  this.doc.nodesBetween(from, to, (node, pos) => {\n    if (node.isTextblock && !node.hasMarkup(type, attrs) && canChangeType(this.doc, this.mapping.slice(mapFrom).map(pos), type)) {\n      // Ensure all markup that isn't allowed in the new node type is cleared\n      this.clearIncompatible(this.mapping.slice(mapFrom).map(pos, 1), type)\n      let mapping = this.mapping.slice(mapFrom)\n      let startM = mapping.map(pos, 1), endM = mapping.map(pos + node.nodeSize, 1)\n      this.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1,\n                                      new Slice(Fragment.from(type.create(attrs, null, node.marks)), 0, 0), 1, true))\n      return false\n    }\n  })\n  return this\n}\n\nfunction canChangeType(doc, pos, type) {\n  let $pos = doc.resolve(pos), index = $pos.index()\n  return $pos.parent.canReplaceWith(index, index + 1, type)\n}\n\n// :: (number, ?NodeType, ?Object, ?[Mark]) \u2192 this\n// Change the type, attributes, and/or marks of the node at `pos`.\n// When `type` isn't given, the existing node type is preserved,\nTransform.prototype.setNodeMarkup = function(pos, type, attrs, marks) {\n  let node = this.doc.nodeAt(pos)\n  if (!node) throw new RangeError(\"No node at given position\")\n  if (!type) type = node.type\n  let newNode = type.create(attrs, null, marks || node.marks)\n  if (node.isLeaf)\n    return this.replaceWith(pos, pos + node.nodeSize, newNode)\n\n  if (!type.validContent(node.content))\n    throw new RangeError(\"Invalid content for node type \" + type.name)\n\n  return this.step(new ReplaceAroundStep(pos, pos + node.nodeSize, pos + 1, pos + node.nodeSize - 1,\n                                         new Slice(Fragment.from(newNode), 0, 0), 1, true))\n}\n\n// :: (Node, number, number, ?[?{type: NodeType, attrs: ?Object}]) \u2192 bool\n// Check whether splitting at the given position is allowed.\nexport function canSplit(doc, pos, depth = 1, typesAfter) {\n  let $pos = doc.resolve(pos), base = $pos.depth - depth\n  let innerType = (typesAfter && typesAfter[typesAfter.length - 1]) || $pos.parent\n  if (base < 0 || $pos.parent.type.spec.isolating ||\n      !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) ||\n      !innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount)))\n    return false\n  for (let d = $pos.depth - 1, i = depth - 2; d > base; d--, i--) {\n    let node = $pos.node(d), index = $pos.index(d)\n    if (node.type.spec.isolating) return false\n    let rest = node.content.cutByIndex(index, node.childCount)\n    let after = (typesAfter && typesAfter[i]) || node\n    if (after != node) rest = rest.replaceChild(0, after.type.create(after.attrs))\n    if (!node.canReplace(index + 1, node.childCount) || !after.type.validContent(rest))\n      return false\n  }\n  let index = $pos.indexAfter(base)\n  let baseType = typesAfter && typesAfter[0]\n  return $pos.node(base).canReplaceWith(index, index, baseType ? baseType.type : $pos.node(base + 1).type)\n}\n\n// :: (number, ?number, ?[?{type: NodeType, attrs: ?Object}]) \u2192 this\n// Split the node at the given position, and optionally, if `depth` is\n// greater than one, any number of nodes above that. By default, the\n// parts split off will inherit the node type of the original node.\n// This can be changed by passing an array of types and attributes to\n// use after the split.\nTransform.prototype.split = function(pos, depth = 1, typesAfter) {\n  let $pos = this.doc.resolve(pos), before = Fragment.empty, after = Fragment.empty\n  for (let d = $pos.depth, e = $pos.depth - depth, i = depth - 1; d > e; d--, i--) {\n    before = Fragment.from($pos.node(d).copy(before))\n    let typeAfter = typesAfter && typesAfter[i]\n    after = Fragment.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after) : $pos.node(d).copy(after))\n  }\n  return this.step(new ReplaceStep(pos, pos, new Slice(before.append(after), depth, depth), true))\n}\n\n// :: (Node, number) \u2192 bool\n// Test whether the blocks before and after a given position can be\n// joined.\nexport function canJoin(doc, pos) {\n  let $pos = doc.resolve(pos), index = $pos.index()\n  return joinable($pos.nodeBefore, $pos.nodeAfter) &&\n    $pos.parent.canReplace(index, index + 1)\n}\n\nfunction joinable(a, b) {\n  return a && b && !a.isLeaf && a.canAppend(b)\n}\n\n// :: (Node, number, ?number) \u2192 ?number\n// Find an ancestor of the given position that can be joined to the\n// block before (or after if `dir` is positive). Returns the joinable\n// point, if any.\nexport function joinPoint(doc, pos, dir = -1) {\n  let $pos = doc.resolve(pos)\n  for (let d = $pos.depth;; d--) {\n    let before, after, index = $pos.index(d)\n    if (d == $pos.depth) {\n      before = $pos.nodeBefore\n      after = $pos.nodeAfter\n    } else if (dir > 0) {\n      before = $pos.node(d + 1)\n      index++\n      after = $pos.node(d).maybeChild(index)\n    } else {\n      before = $pos.node(d).maybeChild(index - 1)\n      after = $pos.node(d + 1)\n    }\n    if (before && !before.isTextblock && joinable(before, after) &&\n        $pos.node(d).canReplace(index, index + 1)) return pos\n    if (d == 0) break\n    pos = dir < 0 ? $pos.before(d) : $pos.after(d)\n  }\n}\n\n// :: (number, ?number) \u2192 this\n// Join the blocks around the given position. If depth is 2, their\n// last and first siblings are also joined, and so on.\nTransform.prototype.join = function(pos, depth = 1) {\n  let step = new ReplaceStep(pos - depth, pos + depth, Slice.empty, true)\n  return this.step(step)\n}\n\n// :: (Node, number, NodeType) \u2192 ?number\n// Try to find a point where a node of the given type can be inserted\n// near `pos`, by searching up the node hierarchy when `pos` itself\n// isn't a valid place but is at the start or end of a node. Return\n// null if no position was found.\nexport function insertPoint(doc, pos, nodeType) {\n  let $pos = doc.resolve(pos)\n  if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType)) return pos\n\n  if ($pos.parentOffset == 0)\n    for (let d = $pos.depth - 1; d >= 0; d--) {\n      let index = $pos.index(d)\n      if ($pos.node(d).canReplaceWith(index, index, nodeType)) return $pos.before(d + 1)\n      if (index > 0) return null\n    }\n  if ($pos.parentOffset == $pos.parent.content.size)\n    for (let d = $pos.depth - 1; d >= 0; d--) {\n      let index = $pos.indexAfter(d)\n      if ($pos.node(d).canReplaceWith(index, index, nodeType)) return $pos.after(d + 1)\n      if (index < $pos.node(d).childCount) return null\n    }\n}\n\n// :: (Node, number, Slice) \u2192 ?number\n// Finds a position at or around the given position where the given\n// slice can be inserted. Will look at parent nodes' nearest boundary\n// and try there, even if the original position wasn't directly at the\n// start or end of that node. Returns null when no position was found.\nexport function dropPoint(doc, pos, slice) {\n  let $pos = doc.resolve(pos)\n  if (!slice.content.size) return pos\n  let content = slice.content\n  for (let i = 0; i < slice.openStart; i++) content = content.firstChild.content\n  for (let pass = 1; pass <= (slice.openStart == 0 && slice.size ? 2 : 1); pass++) {\n    for (let d = $pos.depth; d >= 0; d--) {\n      let bias = d == $pos.depth ? 0 : $pos.pos <= ($pos.start(d + 1) + $pos.end(d + 1)) / 2 ? -1 : 1\n      let insertPos = $pos.index(d) + (bias > 0 ? 1 : 0)\n      let parent = $pos.node(d), fits = false\n      if (pass == 1) {\n        fits = parent.canReplace(insertPos, insertPos, content)\n      } else {\n        let wrapping = parent.contentMatchAt(insertPos).findWrapping(content.firstChild.type)\n        fits = wrapping && parent.canReplaceWith(insertPos, insertPos, wrapping[0])\n      }\n      if (fits)\n        return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d + 1) : $pos.after(d + 1)\n    }\n  }\n  return null\n}\n", "import {Fragment, Slice} from \"prosemirror-model\"\nimport {Step, StepResult} from \"./step\"\n\nfunction mapFragment(fragment, f, parent) {\n  let mapped = []\n  for (let i = 0; i < fragment.childCount; i++) {\n    let child = fragment.child(i)\n    if (child.content.size) child = child.copy(mapFragment(child.content, f, child))\n    if (child.isInline) child = f(child, parent, i)\n    mapped.push(child)\n  }\n  return Fragment.fromArray(mapped)\n}\n\n// ::- Add a mark to all inline content between two positions.\nexport class AddMarkStep extends Step {\n  // :: (number, number, Mark)\n  constructor(from, to, mark) {\n    super()\n    // :: number\n    // The start of the marked range.\n    this.from = from\n    // :: number\n    // The end of the marked range.\n    this.to = to\n    // :: Mark\n    // The mark to add.\n    this.mark = mark\n  }\n\n  apply(doc) {\n    let oldSlice = doc.slice(this.from, this.to), $from = doc.resolve(this.from)\n    let parent = $from.node($from.sharedDepth(this.to))\n    let slice = new Slice(mapFragment(oldSlice.content, (node, parent) => {\n      if (!node.isAtom || !parent.type.allowsMarkType(this.mark.type)) return node\n      return node.mark(this.mark.addToSet(node.marks))\n    }, parent), oldSlice.openStart, oldSlice.openEnd)\n    return StepResult.fromReplace(doc, this.from, this.to, slice)\n  }\n\n  invert() {\n    return new RemoveMarkStep(this.from, this.to, this.mark)\n  }\n\n  map(mapping) {\n    let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1)\n    if (from.deleted && to.deleted || from.pos >= to.pos) return null\n    return new AddMarkStep(from.pos, to.pos, this.mark)\n  }\n\n  merge(other) {\n    if (other instanceof AddMarkStep &&\n        other.mark.eq(this.mark) &&\n        this.from <= other.to && this.to >= other.from)\n      return new AddMarkStep(Math.min(this.from, other.from),\n                             Math.max(this.to, other.to), this.mark)\n  }\n\n  toJSON() {\n    return {stepType: \"addMark\", mark: this.mark.toJSON(),\n            from: this.from, to: this.to}\n  }\n\n  static fromJSON(schema, json) {\n    if (typeof json.from != \"number\" || typeof json.to != \"number\")\n      throw new RangeError(\"Invalid input for AddMarkStep.fromJSON\")\n    return new AddMarkStep(json.from, json.to, schema.markFromJSON(json.mark))\n  }\n}\n\nStep.jsonID(\"addMark\", AddMarkStep)\n\n// ::- Remove a mark from all inline content between two positions.\nexport class RemoveMarkStep extends Step {\n  // :: (number, number, Mark)\n  constructor(from, to, mark) {\n    super()\n    // :: number\n    // The start of the unmarked range.\n    this.from = from\n    // :: number\n    // The end of the unmarked range.\n    this.to = to\n    // :: Mark\n    // The mark to remove.\n    this.mark = mark\n  }\n\n  apply(doc) {\n    let oldSlice = doc.slice(this.from, this.to)\n    let slice = new Slice(mapFragment(oldSlice.content, node => {\n      return node.mark(this.mark.removeFromSet(node.marks))\n    }), oldSlice.openStart, oldSlice.openEnd)\n    return StepResult.fromReplace(doc, this.from, this.to, slice)\n  }\n\n  invert() {\n    return new AddMarkStep(this.from, this.to, this.mark)\n  }\n\n  map(mapping) {\n    let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1)\n    if (from.deleted && to.deleted || from.pos >= to.pos) return null\n    return new RemoveMarkStep(from.pos, to.pos, this.mark)\n  }\n\n  merge(other) {\n    if (other instanceof RemoveMarkStep &&\n        other.mark.eq(this.mark) &&\n        this.from <= other.to && this.to >= other.from)\n      return new RemoveMarkStep(Math.min(this.from, other.from),\n                                Math.max(this.to, other.to), this.mark)\n  }\n\n  toJSON() {\n    return {stepType: \"removeMark\", mark: this.mark.toJSON(),\n            from: this.from, to: this.to}\n  }\n\n  static fromJSON(schema, json) {\n    if (typeof json.from != \"number\" || typeof json.to != \"number\")\n      throw new RangeError(\"Invalid input for RemoveMarkStep.fromJSON\")\n    return new RemoveMarkStep(json.from, json.to, schema.markFromJSON(json.mark))\n  }\n}\n\nStep.jsonID(\"removeMark\", RemoveMarkStep)\n", "import {MarkType, Slice, Fragment} from \"prosemirror-model\"\n\nimport {Transform} from \"./transform\"\nimport {AddMarkStep, RemoveMarkStep} from \"./mark_step\"\nimport {ReplaceStep} from \"./replace_step\"\n\n// :: (number, number, Mark) \u2192 this\n// Add the given mark to the inline content between `from` and `to`.\nTransform.prototype.addMark = function(from, to, mark) {\n  let removed = [], added = [], removing = null, adding = null\n  this.doc.nodesBetween(from, to, (node, pos, parent) => {\n    if (!node.isInline) return\n    let marks = node.marks\n    if (!mark.isInSet(marks) && parent.type.allowsMarkType(mark.type)) {\n      let start = Math.max(pos, from), end = Math.min(pos + node.nodeSize, to)\n      let newSet = mark.addToSet(marks)\n\n      for (let i = 0; i < marks.length; i++) {\n        if (!marks[i].isInSet(newSet)) {\n          if (removing && removing.to == start && removing.mark.eq(marks[i]))\n            removing.to = end\n          else\n            removed.push(removing = new RemoveMarkStep(start, end, marks[i]))\n        }\n      }\n\n      if (adding && adding.to == start)\n        adding.to = end\n      else\n        added.push(adding = new AddMarkStep(start, end, mark))\n    }\n  })\n\n  removed.forEach(s => this.step(s))\n  added.forEach(s => this.step(s))\n  return this\n}\n\n// :: (number, number, ?union<Mark, MarkType>) \u2192 this\n// Remove marks from inline nodes between `from` and `to`. When `mark`\n// is a single mark, remove precisely that mark. When it is a mark type,\n// remove all marks of that type. When it is null, remove all marks of\n// any type.\nTransform.prototype.removeMark = function(from, to, mark = null) {\n  let matched = [], step = 0\n  this.doc.nodesBetween(from, to, (node, pos) => {\n    if (!node.isInline) return\n    step++\n    let toRemove = null\n    if (mark instanceof MarkType) {\n      let set = node.marks, found\n      while (found = mark.isInSet(set)) {\n        ;(toRemove || (toRemove = [])).push(found)\n        set = found.removeFromSet(set)\n      }\n    } else if (mark) {\n      if (mark.isInSet(node.marks)) toRemove = [mark]\n    } else {\n      toRemove = node.marks\n    }\n    if (toRemove && toRemove.length) {\n      let end = Math.min(pos + node.nodeSize, to)\n      for (let i = 0; i < toRemove.length; i++) {\n        let style = toRemove[i], found\n        for (let j = 0; j < matched.length; j++) {\n          let m = matched[j]\n          if (m.step == step - 1 && style.eq(matched[j].style)) found = m\n        }\n        if (found) {\n          found.to = end\n          found.step = step\n        } else {\n          matched.push({style, from: Math.max(pos, from), to: end, step})\n        }\n      }\n    }\n  })\n  matched.forEach(m => this.step(new RemoveMarkStep(m.from, m.to, m.style)))\n  return this\n}\n\n// :: (number, NodeType, ?ContentMatch) \u2192 this\n// Removes all marks and nodes from the content of the node at `pos`\n// that don't match the given new parent node type. Accepts an\n// optional starting [content match](#model.ContentMatch) as third\n// argument.\nTransform.prototype.clearIncompatible = function(pos, parentType, match = parentType.contentMatch) {\n  let node = this.doc.nodeAt(pos)\n  let delSteps = [], cur = pos + 1\n  for (let i = 0; i < node.childCount; i++) {\n    let child = node.child(i), end = cur + child.nodeSize\n    let allowed = match.matchType(child.type, child.attrs)\n    if (!allowed) {\n      delSteps.push(new ReplaceStep(cur, end, Slice.empty))\n    } else {\n      match = allowed\n      for (let j = 0; j < child.marks.length; j++) if (!parentType.allowsMarkType(child.marks[j].type))\n        this.step(new RemoveMarkStep(cur, end, child.marks[j]))\n    }\n    cur = end\n  }\n  if (!match.validEnd) {\n    let fill = match.fillBefore(Fragment.empty, true)\n    this.replace(cur, cur, new Slice(fill, 0, 0))\n  }\n  for (let i = delSteps.length - 1; i >= 0; i--) this.step(delSteps[i])\n  return this\n}\n", "import {Fragment, Slice} from \"prosemirror-model\"\n\nimport {ReplaceStep, ReplaceAroundStep} from \"./replace_step\"\nimport {Transform} from \"./transform\"\nimport {insertPoint} from \"./structure\"\n\n// :: (Node, number, ?number, ?Slice) \u2192 ?Step\n// \u2018Fit\u2019 a slice into a given position in the document, producing a\n// [step](#transform.Step) that inserts it. Will return null if\n// there's no meaningful way to insert the slice here, or inserting it\n// would be a no-op (an empty slice over an empty range).\nexport function replaceStep(doc, from, to = from, slice = Slice.empty) {\n  if (from == to && !slice.size) return null\n\n  let $from = doc.resolve(from), $to = doc.resolve(to)\n  // Optimization -- avoid work if it's obvious that it's not needed.\n  if (fitsTrivially($from, $to, slice)) return new ReplaceStep(from, to, slice)\n  return new Fitter($from, $to, slice).fit()\n}\n\n// :: (number, ?number, ?Slice) \u2192 this\n// Replace the part of the document between `from` and `to` with the\n// given `slice`.\nTransform.prototype.replace = function(from, to = from, slice = Slice.empty) {\n  let step = replaceStep(this.doc, from, to, slice)\n  if (step) this.step(step)\n  return this\n}\n\n// :: (number, number, union<Fragment, Node, [Node]>) \u2192 this\n// Replace the given range with the given content, which may be a\n// fragment, node, or array of nodes.\nTransform.prototype.replaceWith = function(from, to, content) {\n  return this.replace(from, to, new Slice(Fragment.from(content), 0, 0))\n}\n\n// :: (number, number) \u2192 this\n// Delete the content between the given positions.\nTransform.prototype.delete = function(from, to) {\n  return this.replace(from, to, Slice.empty)\n}\n\n// :: (number, union<Fragment, Node, [Node]>) \u2192 this\n// Insert the given content at the given position.\nTransform.prototype.insert = function(pos, content) {\n  return this.replaceWith(pos, pos, content)\n}\n\nfunction fitsTrivially($from, $to, slice) {\n  return !slice.openStart && !slice.openEnd && $from.start() == $to.start() &&\n    $from.parent.canReplace($from.index(), $to.index(), slice.content)\n}\n\n// Algorithm for 'placing' the elements of a slice into a gap:\n//\n// We consider the content of each node that is open to the left to be\n// independently placeable. I.e. in <p(\"foo\"), p(\"bar\")>, when the\n// paragraph on the left is open, \"foo\" can be placed (somewhere on\n// the left side of the replacement gap) independently from p(\"bar\").\n//\n// This class tracks the state of the placement progress in the\n// following properties:\n//\n//  - `frontier` holds a stack of `{type, match}` objects that\n//    represent the open side of the replacement. It starts at\n//    `$from`, then moves forward as content is placed, and is finally\n//    reconciled with `$to`.\n//\n//  - `unplaced` is a slice that represents the content that hasn't\n//    been placed yet.\n//\n//  - `placed` is a fragment of placed content. Its open-start value\n//    is implicit in `$from`, and its open-end value in `frontier`.\nclass Fitter {\n  constructor($from, $to, slice) {\n    this.$to = $to\n    this.$from = $from\n    this.unplaced = slice\n\n    this.frontier = []\n    for (let i = 0; i <= $from.depth; i++) {\n      let node = $from.node(i)\n      this.frontier.push({\n        type: node.type,\n        match: node.contentMatchAt($from.indexAfter(i))\n      })\n    }\n\n    this.placed = Fragment.empty\n    for (let i = $from.depth; i > 0; i--)\n      this.placed = Fragment.from($from.node(i).copy(this.placed))\n  }\n\n  get depth() { return this.frontier.length - 1 }\n\n  fit() {\n    // As long as there's unplaced content, try to place some of it.\n    // If that fails, either increase the open score of the unplaced\n    // slice, or drop nodes from it, and then try again.\n    while (this.unplaced.size) {\n      let fit = this.findFittable()\n      if (fit) this.placeNodes(fit)\n      else this.openMore() || this.dropNode()\n    }\n    // When there's inline content directly after the frontier _and_\n    // directly after `this.$to`, we must generate a `ReplaceAround`\n    // step that pulls that content into the node after the frontier.\n    // That means the fitting must be done to the end of the textblock\n    // node after `this.$to`, not `this.$to` itself.\n    let moveInline = this.mustMoveInline(), placedSize = this.placed.size - this.depth - this.$from.depth\n    let $from = this.$from, $to = this.close(moveInline < 0 ? this.$to : $from.doc.resolve(moveInline))\n    if (!$to) return null\n\n    // If closing to `$to` succeeded, create a step\n    let content = this.placed, openStart = $from.depth, openEnd = $to.depth\n    while (openStart && openEnd && content.childCount == 1) { // Normalize by dropping open parent nodes\n      content = content.firstChild.content\n      openStart--; openEnd--\n    }\n    let slice = new Slice(content, openStart, openEnd)\n    if (moveInline > -1)\n      return new ReplaceAroundStep($from.pos, moveInline, this.$to.pos, this.$to.end(), slice, placedSize)\n    if (slice.size || $from.pos != this.$to.pos) // Don't generate no-op steps\n      return new ReplaceStep($from.pos, $to.pos, slice)\n  }\n\n  // Find a position on the start spine of `this.unplaced` that has\n  // content that can be moved somewhere on the frontier. Returns two\n  // depths, one for the slice and one for the frontier.\n  findFittable() {\n    // Only try wrapping nodes (pass 2) after finding a place without\n    // wrapping failed.\n    for (let pass = 1; pass <= 2; pass++) {\n      for (let sliceDepth = this.unplaced.openStart; sliceDepth >= 0; sliceDepth--) {\n        let fragment, parent\n        if (sliceDepth) {\n          parent = contentAt(this.unplaced.content, sliceDepth - 1).firstChild\n          fragment = parent.content\n        } else {\n          fragment = this.unplaced.content\n        }\n        let first = fragment.firstChild\n        for (let frontierDepth = this.depth; frontierDepth >= 0; frontierDepth--) {\n          let {type, match} = this.frontier[frontierDepth], wrap, inject\n          // In pass 1, if the next node matches, or there is no next\n          // node but the parents look compatible, we've found a\n          // place.\n          if (pass == 1 && (first ? match.matchType(first.type) || (inject = match.fillBefore(Fragment.from(first), false))\n                            : type.compatibleContent(parent.type)))\n            return {sliceDepth, frontierDepth, parent, inject}\n          // In pass 2, look for a set of wrapping nodes that make\n          // `first` fit here.\n          else if (pass == 2 && first && (wrap = match.findWrapping(first.type)))\n            return {sliceDepth, frontierDepth, parent, wrap}\n          // Don't continue looking further up if the parent node\n          // would fit here.\n          if (parent && match.matchType(parent.type)) break\n        }\n      }\n    }\n  }\n\n  openMore() {\n    let {content, openStart, openEnd} = this.unplaced\n    let inner = contentAt(content, openStart)\n    if (!inner.childCount || inner.firstChild.isLeaf) return false\n    this.unplaced = new Slice(content, openStart + 1,\n                              Math.max(openEnd, inner.size + openStart >= content.size - openEnd ? openStart + 1 : 0))\n    return true\n  }\n\n  dropNode() {\n    let {content, openStart, openEnd} = this.unplaced\n    let inner = contentAt(content, openStart)\n    if (inner.childCount <= 1 && openStart > 0) {\n      let openAtEnd = content.size - openStart <= openStart + inner.size\n      this.unplaced = new Slice(dropFromFragment(content, openStart - 1, 1), openStart - 1,\n                                openAtEnd ? openStart - 1 : openEnd)\n    } else {\n      this.unplaced = new Slice(dropFromFragment(content, openStart, 1), openStart, openEnd)\n    }\n  }\n\n  // : ({sliceDepth: number, frontierDepth: number, parent: ?Node, wrap: ?[NodeType], inject: ?Fragment})\n  // Move content from the unplaced slice at `sliceDepth` to the\n  // frontier node at `frontierDepth`. Close that frontier node when\n  // applicable.\n  placeNodes({sliceDepth, frontierDepth, parent, inject, wrap}) {\n    while (this.depth > frontierDepth) this.closeFrontierNode()\n    if (wrap) for (let i = 0; i < wrap.length; i++) this.openFrontierNode(wrap[i])\n\n    let slice = this.unplaced, fragment = parent ? parent.content : slice.content\n    let openStart = slice.openStart - sliceDepth\n    let taken = 0, add = []\n    let {match, type} = this.frontier[frontierDepth]\n    if (inject) {\n      for (let i = 0; i < inject.childCount; i++) add.push(inject.child(i))\n      match = match.matchFragment(inject)\n    }\n    // Computes the amount of (end) open nodes at the end of the\n    // fragment. When 0, the parent is open, but no more. When\n    // negative, nothing is open.\n    let openEndCount = (fragment.size + sliceDepth) - (slice.content.size - slice.openEnd)\n    // Scan over the fragment, fitting as many child nodes as\n    // possible.\n    while (taken < fragment.childCount) {\n      let next = fragment.child(taken), matches = match.matchType(next.type)\n      if (!matches) break\n      taken++\n      if (taken > 1 || openStart == 0 || next.content.size) { // Drop empty open nodes\n        match = matches\n        add.push(closeNodeStart(next.mark(type.allowedMarks(next.marks)), taken == 1 ? openStart : 0,\n                                taken == fragment.childCount ? openEndCount : -1))\n      }\n    }\n    let toEnd = taken == fragment.childCount\n    if (!toEnd) openEndCount = -1\n\n    this.placed = addToFragment(this.placed, frontierDepth, Fragment.from(add))\n    this.frontier[frontierDepth].match = match\n\n    // If the parent types match, and the entire node was moved, and\n    // it's not open, close this frontier node right away.\n    if (toEnd && openEndCount < 0 && parent && parent.type == this.frontier[this.depth].type && this.frontier.length > 1)\n      this.closeFrontierNode()\n\n    // Add new frontier nodes for any open nodes at the end.\n    for (let i = 0, cur = fragment; i < openEndCount; i++) {\n      let node = cur.lastChild\n      this.frontier.push({type: node.type, match: node.contentMatchAt(node.childCount)})\n      cur = node.content\n    }\n\n    // Update `this.unplaced`. Drop the entire node from which we\n    // placed it we got to its end, otherwise just drop the placed\n    // nodes.\n    this.unplaced = !toEnd ? new Slice(dropFromFragment(slice.content, sliceDepth, taken), slice.openStart, slice.openEnd)\n      : sliceDepth == 0 ? Slice.empty\n      : new Slice(dropFromFragment(slice.content, sliceDepth - 1, 1),\n                  sliceDepth - 1, openEndCount < 0 ? slice.openEnd : sliceDepth - 1)\n  }\n\n  mustMoveInline() {\n    if (!this.$to.parent.isTextblock) return -1\n    let top = this.frontier[this.depth], level\n    if (!top.type.isTextblock || !contentAfterFits(this.$to, this.$to.depth, top.type, top.match, false) ||\n        (this.$to.depth == this.depth && (level = this.findCloseLevel(this.$to)) && level.depth == this.depth)) return -1\n\n    let {depth} = this.$to, after = this.$to.after(depth)\n    while (depth > 1 && after == this.$to.end(--depth)) ++after\n    return after\n  }\n\n  findCloseLevel($to) {\n    scan: for (let i = Math.min(this.depth, $to.depth); i >= 0; i--) {\n      let {match, type} = this.frontier[i]\n      let dropInner = i < $to.depth && $to.end(i + 1) == $to.pos + ($to.depth - (i + 1))\n      let fit = contentAfterFits($to, i, type, match, dropInner)\n      if (!fit) continue\n      for (let d = i - 1; d >= 0; d--) {\n        let {match, type} = this.frontier[d]\n        let matches = contentAfterFits($to, d, type, match, true)\n        if (!matches || matches.childCount) continue scan\n      }\n      return {depth: i, fit, move: dropInner ? $to.doc.resolve($to.after(i + 1)) : $to}\n    }\n  }\n\n  close($to) {\n    let close = this.findCloseLevel($to)\n    if (!close) return null\n\n    while (this.depth > close.depth) this.closeFrontierNode()\n    if (close.fit.childCount) this.placed = addToFragment(this.placed, close.depth, close.fit)\n    $to = close.move\n    for (let d = close.depth + 1; d <= $to.depth; d++) {\n      let node = $to.node(d), add = node.type.contentMatch.fillBefore(node.content, true, $to.index(d))\n      this.openFrontierNode(node.type, node.attrs, add)\n    }\n    return $to\n  }\n\n  openFrontierNode(type, attrs, content) {\n    let top = this.frontier[this.depth]\n    top.match = top.match.matchType(type)\n    this.placed = addToFragment(this.placed, this.depth, Fragment.from(type.create(attrs, content)))\n    this.frontier.push({type, match: type.contentMatch})\n  }\n\n  closeFrontierNode() {\n    let open = this.frontier.pop()\n    let add = open.match.fillBefore(Fragment.empty, true)\n    if (add.childCount) this.placed = addToFragment(this.placed, this.frontier.length, add)\n  }\n}\n\nfunction dropFromFragment(fragment, depth, count) {\n  if (depth == 0) return fragment.cutByIndex(count)\n  return fragment.replaceChild(0, fragment.firstChild.copy(dropFromFragment(fragment.firstChild.content, depth - 1, count)))\n}\n\nfunction addToFragment(fragment, depth, content) {\n  if (depth == 0) return fragment.append(content)\n  return fragment.replaceChild(fragment.childCount - 1,\n                               fragment.lastChild.copy(addToFragment(fragment.lastChild.content, depth - 1, content)))\n}\n\nfunction contentAt(fragment, depth) {\n  for (let i = 0; i < depth; i++) fragment = fragment.firstChild.content\n  return fragment\n}\n\nfunction closeNodeStart(node, openStart, openEnd) {\n  if (openStart <= 0) return node\n  let frag = node.content\n  if (openStart > 1)\n    frag = frag.replaceChild(0, closeNodeStart(frag.firstChild, openStart - 1, frag.childCount == 1 ? openEnd - 1 : 0))\n  if (openStart > 0) {\n    frag = node.type.contentMatch.fillBefore(frag).append(frag)\n    if (openEnd <= 0) frag = frag.append(node.type.contentMatch.matchFragment(frag).fillBefore(Fragment.empty, true))\n  }\n  return node.copy(frag)\n}\n\nfunction contentAfterFits($to, depth, type, match, open) {\n  let node = $to.node(depth), index = open ? $to.indexAfter(depth) : $to.index(depth)\n  if (index == node.childCount && !type.compatibleContent(node.type)) return null\n  let fit = match.fillBefore(node.content, true, index)\n  return fit && !invalidMarks(type, node.content, index) ? fit : null\n}\n\nfunction invalidMarks(type, fragment, start) {\n  for (let i = start; i < fragment.childCount; i++)\n    if (!type.allowsMarks(fragment.child(i).marks)) return true\n  return false\n}\n\nfunction definesContent(type) {\n  return type.spec.defining || type.spec.definingForContent\n}\n\n// :: (number, number, Slice) \u2192 this\n// Replace a range of the document with a given slice, using `from`,\n// `to`, and the slice's [`openStart`](#model.Slice.openStart) property\n// as hints, rather than fixed start and end points. This method may\n// grow the replaced area or close open nodes in the slice in order to\n// get a fit that is more in line with WYSIWYG expectations, by\n// dropping fully covered parent nodes of the replaced region when\n// they are marked [non-defining as context](#model.NodeSpec.definingAsContext), or\n// including an open parent node from the slice that _is_ marked as\n// [defining its content](#model.NodeSpec.definingForContent).\n//\n// This is the method, for example, to handle paste. The similar\n// [`replace`](#transform.Transform.replace) method is a more\n// primitive tool which will _not_ move the start and end of its given\n// range, and is useful in situations where you need more precise\n// control over what happens.\nTransform.prototype.replaceRange = function(from, to, slice) {\n  if (!slice.size) return this.deleteRange(from, to)\n\n  let $from = this.doc.resolve(from), $to = this.doc.resolve(to)\n  if (fitsTrivially($from, $to, slice))\n    return this.step(new ReplaceStep(from, to, slice))\n\n  let targetDepths = coveredDepths($from, this.doc.resolve(to))\n  // Can't replace the whole document, so remove 0 if it's present\n  if (targetDepths[targetDepths.length - 1] == 0) targetDepths.pop()\n  // Negative numbers represent not expansion over the whole node at\n  // that depth, but replacing from $from.before(-D) to $to.pos.\n  let preferredTarget = -($from.depth + 1)\n  targetDepths.unshift(preferredTarget)\n  // This loop picks a preferred target depth, if one of the covering\n  // depths is not outside of a defining node, and adds negative\n  // depths for any depth that has $from at its start and does not\n  // cross a defining node.\n  for (let d = $from.depth, pos = $from.pos - 1; d > 0; d--, pos--) {\n    let spec = $from.node(d).type.spec\n    if (spec.defining || spec.definingAsContext || spec.isolating) break\n    if (targetDepths.indexOf(d) > -1) preferredTarget = d\n    else if ($from.before(d) == pos) targetDepths.splice(1, 0, -d)\n  }\n  // Try to fit each possible depth of the slice into each possible\n  // target depth, starting with the preferred depths.\n  let preferredTargetIndex = targetDepths.indexOf(preferredTarget)\n\n  let leftNodes = [], preferredDepth = slice.openStart\n  for (let content = slice.content, i = 0;; i++) {\n    let node = content.firstChild\n    leftNodes.push(node)\n    if (i == slice.openStart) break\n    content = node.content\n  }\n\n  // Back up preferredDepth to cover defining textblocks directly\n  // above it, possibly skipping a non-defining textblock.\n  for (let d = preferredDepth - 1; d >= 0; d--) {\n    let type = leftNodes[d].type, def = definesContent(type)\n    if (def && $from.node(preferredTargetIndex).type != type) preferredDepth = d\n    else if (def || !type.isTextblock) break\n  }\n\n  for (let j = slice.openStart; j >= 0; j--) {\n    let openDepth = (j + preferredDepth + 1) % (slice.openStart + 1)\n    let insert = leftNodes[openDepth]\n    if (!insert) continue\n    for (let i = 0; i < targetDepths.length; i++) {\n      // Loop over possible expansion levels, starting with the\n      // preferred one\n      let targetDepth = targetDepths[(i + preferredTargetIndex) % targetDepths.length], expand = true\n      if (targetDepth < 0) { expand = false; targetDepth = -targetDepth }\n      let parent = $from.node(targetDepth - 1), index = $from.index(targetDepth - 1)\n      if (parent.canReplaceWith(index, index, insert.type, insert.marks))\n        return this.replace($from.before(targetDepth), expand ? $to.after(targetDepth) : to,\n                            new Slice(closeFragment(slice.content, 0, slice.openStart, openDepth),\n                                      openDepth, slice.openEnd))\n    }\n  }\n\n  let startSteps = this.steps.length\n  for (let i = targetDepths.length - 1; i >= 0; i--) {\n    this.replace(from, to, slice)\n    if (this.steps.length > startSteps) break\n    let depth = targetDepths[i]\n    if (depth < 0) continue\n    from = $from.before(depth); to = $to.after(depth)\n  }\n  return this\n}\n\nfunction closeFragment(fragment, depth, oldOpen, newOpen, parent) {\n  if (depth < oldOpen) {\n    let first = fragment.firstChild\n    fragment = fragment.replaceChild(0, first.copy(closeFragment(first.content, depth + 1, oldOpen, newOpen, first)))\n  }\n  if (depth > newOpen) {\n    let match = parent.contentMatchAt(0)\n    let start = match.fillBefore(fragment).append(fragment)\n    fragment = start.append(match.matchFragment(start).fillBefore(Fragment.empty, true))\n  }\n  return fragment\n}\n\n// :: (number, number, Node) \u2192 this\n// Replace the given range with a node, but use `from` and `to` as\n// hints, rather than precise positions. When from and to are the same\n// and are at the start or end of a parent node in which the given\n// node doesn't fit, this method may _move_ them out towards a parent\n// that does allow the given node to be placed. When the given range\n// completely covers a parent node, this method may completely replace\n// that parent node.\nTransform.prototype.replaceRangeWith = function(from, to, node) {\n  if (!node.isInline && from == to && this.doc.resolve(from).parent.content.size) {\n    let point = insertPoint(this.doc, from, node.type)\n    if (point != null) from = to = point\n  }\n  return this.replaceRange(from, to, new Slice(Fragment.from(node), 0, 0))\n}\n\n// :: (number, number) \u2192 this\n// Delete the given range, expanding it to cover fully covered\n// parent nodes until a valid replace is found.\nTransform.prototype.deleteRange = function(from, to) {\n  let $from = this.doc.resolve(from), $to = this.doc.resolve(to)\n  let covered = coveredDepths($from, $to)\n  for (let i = 0; i < covered.length; i++) {\n    let depth = covered[i], last = i == covered.length - 1\n    if ((last && depth == 0) || $from.node(depth).type.contentMatch.validEnd)\n      return this.delete($from.start(depth), $to.end(depth))\n    if (depth > 0 && (last || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1))))\n      return this.delete($from.before(depth), $to.after(depth))\n  }\n  for (let d = 1; d <= $from.depth && d <= $to.depth; d++) {\n    if (from - $from.start(d) == $from.depth - d && to > $from.end(d) && $to.end(d) - to != $to.depth - d)\n      return this.delete($from.before(d), to)\n  }\n  return this.delete(from, to)\n}\n\n// : (ResolvedPos, ResolvedPos) \u2192 [number]\n// Returns an array of all depths for which $from - $to spans the\n// whole content of the nodes at that depth.\nfunction coveredDepths($from, $to) {\n  let result = [], minDepth = Math.min($from.depth, $to.depth)\n  for (let d = minDepth; d >= 0; d--) {\n    let start = $from.start(d)\n    if (start < $from.pos - ($from.depth - d) ||\n        $to.end(d) > $to.pos + ($to.depth - d) ||\n        $from.node(d).type.spec.isolating ||\n        $to.node(d).type.spec.isolating) break\n    if (start == $to.start(d) ||\n        (d == $from.depth && d == $to.depth && $from.parent.inlineContent && $to.parent.inlineContent &&\n         d && $to.start(d - 1) == start - 1))\n      result.push(d)\n  }\n  return result\n}\n", "import {joinPoint, canJoin, findWrapping, liftTarget, canSplit, ReplaceAroundStep, replaceStep} from \"prosemirror-transform\"\nimport {Slice, Fragment} from \"prosemirror-model\"\nimport {Selection, TextSelection, NodeSelection, AllSelection} from \"prosemirror-state\"\n\n// :: (EditorState, ?(tr: Transaction)) \u2192 bool\n// Delete the selection, if there is one.\nexport function deleteSelection(state, dispatch) {\n  if (state.selection.empty) return false\n  if (dispatch) dispatch(state.tr.deleteSelection().scrollIntoView())\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction), ?EditorView) \u2192 bool\n// If the selection is empty and at the start of a textblock, try to\n// reduce the distance between that block and the one before it\u2014if\n// there's a block directly before it that can be joined, join them.\n// If not, try to move the selected block closer to the next one in\n// the document structure by lifting it out of its parent or moving it\n// into a parent of the previous block. Will use the view for accurate\n// (bidi-aware) start-of-textblock detection if given.\nexport function joinBackward(state, dispatch, view) {\n  let {$cursor} = state.selection\n  if (!$cursor || (view ? !view.endOfTextblock(\"backward\", state)\n                        : $cursor.parentOffset > 0))\n    return false\n\n  let $cut = findCutBefore($cursor)\n\n  // If there is no node before this, try to lift\n  if (!$cut) {\n    let range = $cursor.blockRange(), target = range && liftTarget(range)\n    if (target == null) return false\n    if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView())\n    return true\n  }\n\n  let before = $cut.nodeBefore\n  // Apply the joining algorithm\n  if (!before.type.spec.isolating && deleteBarrier(state, $cut, dispatch))\n    return true\n\n  // If the node below has no content and the node above is\n  // selectable, delete the node below and select the one above.\n  if ($cursor.parent.content.size == 0 &&\n      (textblockAt(before, \"end\") || NodeSelection.isSelectable(before))) {\n    let delStep = replaceStep(state.doc, $cursor.before(), $cursor.after(), Slice.empty)\n    if (delStep.slice.size < delStep.to - delStep.from) {\n      if (dispatch) {\n        let tr = state.tr.step(delStep)\n        tr.setSelection(textblockAt(before, \"end\") ? Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos, -1)), -1)\n                        : NodeSelection.create(tr.doc, $cut.pos - before.nodeSize))\n        dispatch(tr.scrollIntoView())\n      }\n      return true\n    }\n  }\n\n  // If the node before is an atom, delete it\n  if (before.isAtom && $cut.depth == $cursor.depth - 1) {\n    if (dispatch) dispatch(state.tr.delete($cut.pos - before.nodeSize, $cut.pos).scrollIntoView())\n    return true\n  }\n\n  return false\n}\n\nfunction textblockAt(node, side, only) {\n  for (; node; node = (side == \"start\" ? node.firstChild : node.lastChild)) {\n    if (node.isTextblock) return true\n    if (only && node.childCount != 1) return false\n  }\n  return false\n}\n\n// :: (EditorState, ?(tr: Transaction), ?EditorView) \u2192 bool\n// When the selection is empty and at the start of a textblock, select\n// the node before that textblock, if possible. This is intended to be\n// bound to keys like backspace, after\n// [`joinBackward`](#commands.joinBackward) or other deleting\n// commands, as a fall-back behavior when the schema doesn't allow\n// deletion at the selected point.\nexport function selectNodeBackward(state, dispatch, view) {\n  let {$head, empty} = state.selection, $cut = $head\n  if (!empty) return false\n\n  if ($head.parent.isTextblock) {\n    if (view ? !view.endOfTextblock(\"backward\", state) : $head.parentOffset > 0) return false\n    $cut = findCutBefore($head)\n  }\n  let node = $cut && $cut.nodeBefore\n  if (!node || !NodeSelection.isSelectable(node)) return false\n  if (dispatch)\n    dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos - node.nodeSize)).scrollIntoView())\n  return true\n}\n\nfunction findCutBefore($pos) {\n  if (!$pos.parent.type.spec.isolating) for (let i = $pos.depth - 1; i >= 0; i--) {\n    if ($pos.index(i) > 0) return $pos.doc.resolve($pos.before(i + 1))\n    if ($pos.node(i).type.spec.isolating) break\n  }\n  return null\n}\n\n// :: (EditorState, ?(tr: Transaction), ?EditorView) \u2192 bool\n// If the selection is empty and the cursor is at the end of a\n// textblock, try to reduce or remove the boundary between that block\n// and the one after it, either by joining them or by moving the other\n// block closer to this one in the tree structure. Will use the view\n// for accurate start-of-textblock detection if given.\nexport function joinForward(state, dispatch, view) {\n  let {$cursor} = state.selection\n  if (!$cursor || (view ? !view.endOfTextblock(\"forward\", state)\n                        : $cursor.parentOffset < $cursor.parent.content.size))\n    return false\n\n  let $cut = findCutAfter($cursor)\n\n  // If there is no node after this, there's nothing to do\n  if (!$cut) return false\n\n  let after = $cut.nodeAfter\n  // Try the joining algorithm\n  if (deleteBarrier(state, $cut, dispatch)) return true\n\n  // If the node above has no content and the node below is\n  // selectable, delete the node above and select the one below.\n  if ($cursor.parent.content.size == 0 &&\n      (textblockAt(after, \"start\") || NodeSelection.isSelectable(after))) {\n    let delStep = replaceStep(state.doc, $cursor.before(), $cursor.after(), Slice.empty)\n    if (delStep.slice.size < delStep.to - delStep.from) {\n      if (dispatch) {\n        let tr = state.tr.step(delStep)\n        tr.setSelection(textblockAt(after, \"start\") ? Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos)), 1)\n                        : NodeSelection.create(tr.doc, tr.mapping.map($cut.pos)))\n        dispatch(tr.scrollIntoView())\n      }\n      return true\n    }\n  }\n\n  // If the next node is an atom, delete it\n  if (after.isAtom && $cut.depth == $cursor.depth - 1) {\n    if (dispatch) dispatch(state.tr.delete($cut.pos, $cut.pos + after.nodeSize).scrollIntoView())\n    return true\n  }\n\n  return false\n}\n\n// :: (EditorState, ?(tr: Transaction), ?EditorView) \u2192 bool\n// When the selection is empty and at the end of a textblock, select\n// the node coming after that textblock, if possible. This is intended\n// to be bound to keys like delete, after\n// [`joinForward`](#commands.joinForward) and similar deleting\n// commands, to provide a fall-back behavior when the schema doesn't\n// allow deletion at the selected point.\nexport function selectNodeForward(state, dispatch, view) {\n  let {$head, empty} = state.selection, $cut = $head\n  if (!empty) return false\n  if ($head.parent.isTextblock) {\n    if (view ? !view.endOfTextblock(\"forward\", state) : $head.parentOffset < $head.parent.content.size)\n      return false\n    $cut = findCutAfter($head)\n  }\n  let node = $cut && $cut.nodeAfter\n  if (!node || !NodeSelection.isSelectable(node)) return false\n  if (dispatch)\n    dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos)).scrollIntoView())\n  return true\n}\n\nfunction findCutAfter($pos) {\n  if (!$pos.parent.type.spec.isolating) for (let i = $pos.depth - 1; i >= 0; i--) {\n    let parent = $pos.node(i)\n    if ($pos.index(i) + 1 < parent.childCount) return $pos.doc.resolve($pos.after(i + 1))\n    if (parent.type.spec.isolating) break\n  }\n  return null\n}\n\n// :: (EditorState, ?(tr: Transaction)) \u2192 bool\n// Join the selected block or, if there is a text selection, the\n// closest ancestor block of the selection that can be joined, with\n// the sibling above it.\nexport function joinUp(state, dispatch) {\n  let sel = state.selection, nodeSel = sel instanceof NodeSelection, point\n  if (nodeSel) {\n    if (sel.node.isTextblock || !canJoin(state.doc, sel.from)) return false\n    point = sel.from\n  } else {\n    point = joinPoint(state.doc, sel.from, -1)\n    if (point == null) return false\n  }\n  if (dispatch) {\n    let tr = state.tr.join(point)\n    if (nodeSel) tr.setSelection(NodeSelection.create(tr.doc, point - state.doc.resolve(point).nodeBefore.nodeSize))\n    dispatch(tr.scrollIntoView())\n  }\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) \u2192 bool\n// Join the selected block, or the closest ancestor of the selection\n// that can be joined, with the sibling after it.\nexport function joinDown(state, dispatch) {\n  let sel = state.selection, point\n  if (sel instanceof NodeSelection) {\n    if (sel.node.isTextblock || !canJoin(state.doc, sel.to)) return false\n    point = sel.to\n  } else {\n    point = joinPoint(state.doc, sel.to, 1)\n    if (point == null) return false\n  }\n  if (dispatch)\n    dispatch(state.tr.join(point).scrollIntoView())\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) \u2192 bool\n// Lift the selected block, or the closest ancestor block of the\n// selection that can be lifted, out of its parent node.\nexport function lift(state, dispatch) {\n  let {$from, $to} = state.selection\n  let range = $from.blockRange($to), target = range && liftTarget(range)\n  if (target == null) return false\n  if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView())\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) \u2192 bool\n// If the selection is in a node whose type has a truthy\n// [`code`](#model.NodeSpec.code) property in its spec, replace the\n// selection with a newline character.\nexport function newlineInCode(state, dispatch) {\n  let {$head, $anchor} = state.selection\n  if (!$head.parent.type.spec.code || !$head.sameParent($anchor)) return false\n  if (dispatch) dispatch(state.tr.insertText(\"\\n\").scrollIntoView())\n  return true\n}\n\nfunction defaultBlockAt(match) {\n  for (let i = 0; i < match.edgeCount; i++) {\n    let {type} = match.edge(i)\n    if (type.isTextblock && !type.hasRequiredAttrs()) return type\n  }\n  return null\n}\n\n// :: (EditorState, ?(tr: Transaction)) \u2192 bool\n// When the selection is in a node with a truthy\n// [`code`](#model.NodeSpec.code) property in its spec, create a\n// default block after the code block, and move the cursor there.\nexport function exitCode(state, dispatch) {\n  let {$head, $anchor} = state.selection\n  if (!$head.parent.type.spec.code || !$head.sameParent($anchor)) return false\n  let above = $head.node(-1), after = $head.indexAfter(-1), type = defaultBlockAt(above.contentMatchAt(after))\n  if (!above.canReplaceWith(after, after, type)) return false\n  if (dispatch) {\n    let pos = $head.after(), tr = state.tr.replaceWith(pos, pos, type.createAndFill())\n    tr.setSelection(Selection.near(tr.doc.resolve(pos), 1))\n    dispatch(tr.scrollIntoView())\n  }\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) \u2192 bool\n// If a block node is selected, create an empty paragraph before (if\n// it is its parent's first child) or after it.\nexport function createParagraphNear(state, dispatch) {\n  let sel = state.selection, {$from, $to} = sel\n  if (sel instanceof AllSelection || $from.parent.inlineContent || $to.parent.inlineContent) return false\n  let type = defaultBlockAt($to.parent.contentMatchAt($to.indexAfter()))\n  if (!type || !type.isTextblock) return false\n  if (dispatch) {\n    let side = (!$from.parentOffset && $to.index() < $to.parent.childCount ? $from : $to).pos\n    let tr = state.tr.insert(side, type.createAndFill())\n    tr.setSelection(TextSelection.create(tr.doc, side + 1))\n    dispatch(tr.scrollIntoView())\n  }\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) \u2192 bool\n// If the cursor is in an empty textblock that can be lifted, lift the\n// block.\nexport function liftEmptyBlock(state, dispatch) {\n  let {$cursor} = state.selection\n  if (!$cursor || $cursor.parent.content.size) return false\n  if ($cursor.depth > 1 && $cursor.after() != $cursor.end(-1)) {\n    let before = $cursor.before()\n    if (canSplit(state.doc, before)) {\n      if (dispatch) dispatch(state.tr.split(before).scrollIntoView())\n      return true\n    }\n  }\n  let range = $cursor.blockRange(), target = range && liftTarget(range)\n  if (target == null) return false\n  if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView())\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) \u2192 bool\n// Split the parent block of the selection. If the selection is a text\n// selection, also delete its content.\nexport function splitBlock(state, dispatch) {\n  let {$from, $to} = state.selection\n  if (state.selection instanceof NodeSelection && state.selection.node.isBlock) {\n    if (!$from.parentOffset || !canSplit(state.doc, $from.pos)) return false\n    if (dispatch) dispatch(state.tr.split($from.pos).scrollIntoView())\n    return true\n  }\n\n  if (!$from.parent.isBlock) return false\n\n  if (dispatch) {\n    let atEnd = $to.parentOffset == $to.parent.content.size\n    let tr = state.tr\n    if (state.selection instanceof TextSelection || state.selection instanceof AllSelection) tr.deleteSelection()\n    let deflt = $from.depth == 0 ? null : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)))\n    let types = atEnd && deflt ? [{type: deflt}] : null\n    let can = canSplit(tr.doc, tr.mapping.map($from.pos), 1, types)\n    if (!types && !can && canSplit(tr.doc, tr.mapping.map($from.pos), 1, deflt && [{type: deflt}])) {\n      types = [{type: deflt}]\n      can = true\n    }\n    if (can) {\n      tr.split(tr.mapping.map($from.pos), 1, types)\n      if (!atEnd && !$from.parentOffset && $from.parent.type != deflt) {\n        let first = tr.mapping.map($from.before()), $first = tr.doc.resolve(first)\n        if ($from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt))\n          tr.setNodeMarkup(tr.mapping.map($from.before()), deflt)\n      }\n    }\n    dispatch(tr.scrollIntoView())\n  }\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) \u2192 bool\n// Acts like [`splitBlock`](#commands.splitBlock), but without\n// resetting the set of active marks at the cursor.\nexport function splitBlockKeepMarks(state, dispatch) {\n  return splitBlock(state, dispatch && (tr => {\n    let marks = state.storedMarks || (state.selection.$to.parentOffset && state.selection.$from.marks())\n    if (marks) tr.ensureMarks(marks)\n    dispatch(tr)\n  }))\n}\n\n// :: (EditorState, ?(tr: Transaction)) \u2192 bool\n// Move the selection to the node wrapping the current selection, if\n// any. (Will not select the document node.)\nexport function selectParentNode(state, dispatch) {\n  let {$from, to} = state.selection, pos\n  let same = $from.sharedDepth(to)\n  if (same == 0) return false\n  pos = $from.before(same)\n  if (dispatch) dispatch(state.tr.setSelection(NodeSelection.create(state.doc, pos)))\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) \u2192 bool\n// Select the whole document.\nexport function selectAll(state, dispatch) {\n  if (dispatch) dispatch(state.tr.setSelection(new AllSelection(state.doc)))\n  return true\n}\n\nfunction joinMaybeClear(state, $pos, dispatch) {\n  let before = $pos.nodeBefore, after = $pos.nodeAfter, index = $pos.index()\n  if (!before || !after || !before.type.compatibleContent(after.type)) return false\n  if (!before.content.size && $pos.parent.canReplace(index - 1, index)) {\n    if (dispatch) dispatch(state.tr.delete($pos.pos - before.nodeSize, $pos.pos).scrollIntoView())\n    return true\n  }\n  if (!$pos.parent.canReplace(index, index + 1) || !(after.isTextblock || canJoin(state.doc, $pos.pos)))\n    return false\n  if (dispatch)\n    dispatch(state.tr\n             .clearIncompatible($pos.pos, before.type, before.contentMatchAt(before.childCount))\n             .join($pos.pos)\n             .scrollIntoView())\n  return true\n}\n\nfunction deleteBarrier(state, $cut, dispatch) {\n  let before = $cut.nodeBefore, after = $cut.nodeAfter, conn, match\n  if (before.type.spec.isolating || after.type.spec.isolating) return false\n  if (joinMaybeClear(state, $cut, dispatch)) return true\n\n  let canDelAfter = $cut.parent.canReplace($cut.index(), $cut.index() + 1)\n  if (canDelAfter &&\n      (conn = (match = before.contentMatchAt(before.childCount)).findWrapping(after.type)) &&\n      match.matchType(conn[0] || after.type).validEnd) {\n    if (dispatch) {\n      let end = $cut.pos + after.nodeSize, wrap = Fragment.empty\n      for (let i = conn.length - 1; i >= 0; i--)\n        wrap = Fragment.from(conn[i].create(null, wrap))\n      wrap = Fragment.from(before.copy(wrap))\n      let tr = state.tr.step(new ReplaceAroundStep($cut.pos - 1, end, $cut.pos, end, new Slice(wrap, 1, 0), conn.length, true))\n      let joinAt = end + 2 * conn.length\n      if (canJoin(tr.doc, joinAt)) tr.join(joinAt)\n      dispatch(tr.scrollIntoView())\n    }\n    return true\n  }\n\n  let selAfter = Selection.findFrom($cut, 1)\n  let range = selAfter && selAfter.$from.blockRange(selAfter.$to), target = range && liftTarget(range)\n  if (target != null && target >= $cut.depth) {\n    if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView())\n    return true\n  }\n\n  if (canDelAfter && textblockAt(after, \"start\", true) && textblockAt(before, \"end\")) {\n    let at = before, wrap = []\n    for (;;) {\n      wrap.push(at)\n      if (at.isTextblock) break\n      at = at.lastChild\n    }\n    let afterText = after, afterDepth = 1\n    for (; !afterText.isTextblock; afterText = afterText.firstChild) afterDepth++\n    if (at.canReplace(at.childCount, at.childCount, afterText.content)) {\n      if (dispatch) {\n        let end = Fragment.empty\n        for (let i = wrap.length - 1; i >= 0; i--) end = Fragment.from(wrap[i].copy(end))\n        let tr = state.tr.step(new ReplaceAroundStep($cut.pos - wrap.length, $cut.pos + after.nodeSize,\n                                                     $cut.pos + afterDepth, $cut.pos + after.nodeSize - afterDepth,\n                                                     new Slice(end, wrap.length, 0), 0, true))\n        dispatch(tr.scrollIntoView())\n      }\n      return true\n    }\n  }\n\n  return false\n}\n\nfunction selectTextblockSide(side) {\n  return function(state, dispatch) {\n    let sel = state.selection, $pos = side < 0 ? sel.$from : sel.$to\n    let depth = $pos.depth\n    while ($pos.node(depth).isInline) {\n      if (!depth) return false\n      depth--\n    }\n    if (!$pos.node(depth).isTextblock) return false\n    if (dispatch)\n      dispatch(state.tr.setSelection(TextSelection.create(\n        state.doc, side < 0 ? $pos.start(depth) : $pos.end(depth))))\n    return true\n  }\n}\n\n// :: (EditorState, ?(tr: Transaction)) \u2192 bool\n// Moves the cursor to the start of current text block.\nexport const selectTextblockStart = selectTextblockSide(-1)\n\n// :: (EditorState, ?(tr: Transaction)) \u2192 bool\n// Moves the cursor to the end of current text block.\nexport const selectTextblockEnd = selectTextblockSide(1)\n\n// Parameterized commands\n\n// :: (NodeType, ?Object) \u2192 (state: EditorState, dispatch: ?(tr: Transaction)) \u2192 bool\n// Wrap the selection in a node of the given type with the given\n// attributes.\nexport function wrapIn(nodeType, attrs) {\n  return function(state, dispatch) {\n    let {$from, $to} = state.selection\n    let range = $from.blockRange($to), wrapping = range && findWrapping(range, nodeType, attrs)\n    if (!wrapping) return false\n    if (dispatch) dispatch(state.tr.wrap(range, wrapping).scrollIntoView())\n    return true\n  }\n}\n\n// :: (NodeType, ?Object) \u2192 (state: EditorState, dispatch: ?(tr: Transaction)) \u2192 bool\n// Returns a command that tries to set the selected textblocks to the\n// given node type with the given attributes.\nexport function setBlockType(nodeType, attrs) {\n  return function(state, dispatch) {\n    let {from, to} = state.selection\n    let applicable = false\n    state.doc.nodesBetween(from, to, (node, pos) => {\n      if (applicable) return false\n      if (!node.isTextblock || node.hasMarkup(nodeType, attrs)) return\n      if (node.type == nodeType) {\n        applicable = true\n      } else {\n        let $pos = state.doc.resolve(pos), index = $pos.index()\n        applicable = $pos.parent.canReplaceWith(index, index + 1, nodeType)\n      }\n    })\n    if (!applicable) return false\n    if (dispatch) dispatch(state.tr.setBlockType(from, to, nodeType, attrs).scrollIntoView())\n    return true\n  }\n}\n\nfunction markApplies(doc, ranges, type) {\n  for (let i = 0; i < ranges.length; i++) {\n    let {$from, $to} = ranges[i]\n    let can = $from.depth == 0 ? doc.type.allowsMarkType(type) : false\n    doc.nodesBetween($from.pos, $to.pos, node => {\n      if (can) return false\n      can = node.inlineContent && node.type.allowsMarkType(type)\n    })\n    if (can) return true\n  }\n  return false\n}\n\n// :: (MarkType, ?Object) \u2192 (state: EditorState, dispatch: ?(tr: Transaction)) \u2192 bool\n// Create a command function that toggles the given mark with the\n// given attributes. Will return `false` when the current selection\n// doesn't support that mark. This will remove the mark if any marks\n// of that type exist in the selection, or add it otherwise. If the\n// selection is empty, this applies to the [stored\n// marks](#state.EditorState.storedMarks) instead of a range of the\n// document.\nexport function toggleMark(markType, attrs) {\n  return function(state, dispatch) {\n    let {empty, $cursor, ranges} = state.selection\n    if ((empty && !$cursor) || !markApplies(state.doc, ranges, markType)) return false\n    if (dispatch) {\n      if ($cursor) {\n        if (markType.isInSet(state.storedMarks || $cursor.marks()))\n          dispatch(state.tr.removeStoredMark(markType))\n        else\n          dispatch(state.tr.addStoredMark(markType.create(attrs)))\n      } else {\n        let has = false, tr = state.tr\n        for (let i = 0; !has && i < ranges.length; i++) {\n          let {$from, $to} = ranges[i]\n          has = state.doc.rangeHasMark($from.pos, $to.pos, markType)\n        }\n        for (let i = 0; i < ranges.length; i++) {\n          let {$from, $to} = ranges[i]\n          if (has) {\n            tr.removeMark($from.pos, $to.pos, markType)\n          } else {\n            let from = $from.pos, to = $to.pos, start = $from.nodeAfter, end = $to.nodeBefore\n            let spaceStart = start && start.isText ? /^\\s*/.exec(start.text)[0].length : 0\n            let spaceEnd = end && end.isText ? /\\s*$/.exec(end.text)[0].length : 0\n            if (from + spaceStart < to) { from += spaceStart; to -= spaceEnd }\n            tr.addMark(from, to, markType.create(attrs))\n          }\n        }\n        dispatch(tr.scrollIntoView())\n      }\n    }\n    return true\n  }\n}\n\nfunction wrapDispatchForJoin(dispatch, isJoinable) {\n  return tr => {\n    if (!tr.isGeneric) return dispatch(tr)\n\n    let ranges = []\n    for (let i = 0; i < tr.mapping.maps.length; i++) {\n      let map = tr.mapping.maps[i]\n      for (let j = 0; j < ranges.length; j++)\n        ranges[j] = map.map(ranges[j])\n      map.forEach((_s, _e, from, to) => ranges.push(from, to))\n    }\n\n    // Figure out which joinable points exist inside those ranges,\n    // by checking all node boundaries in their parent nodes.\n    let joinable = []\n    for (let i = 0; i < ranges.length; i += 2) {\n      let from = ranges[i], to = ranges[i + 1]\n      let $from = tr.doc.resolve(from), depth = $from.sharedDepth(to), parent = $from.node(depth)\n      for (let index = $from.indexAfter(depth), pos = $from.after(depth + 1); pos <= to; ++index) {\n        let after = parent.maybeChild(index)\n        if (!after) break\n        if (index && joinable.indexOf(pos) == -1) {\n          let before = parent.child(index - 1)\n          if (before.type == after.type && isJoinable(before, after))\n            joinable.push(pos)\n        }\n        pos += after.nodeSize\n      }\n    }\n    // Join the joinable points\n    joinable.sort((a, b) => a - b)\n    for (let i = joinable.length - 1; i >= 0; i--) {\n      if (canJoin(tr.doc, joinable[i])) tr.join(joinable[i])\n    }\n    dispatch(tr)\n  }\n}\n\n// :: ((state: EditorState, ?(tr: Transaction)) \u2192 bool, union<(before: Node, after: Node) \u2192 bool, [string]>) \u2192 (state: EditorState, ?(tr: Transaction)) \u2192 bool\n// Wrap a command so that, when it produces a transform that causes\n// two joinable nodes to end up next to each other, those are joined.\n// Nodes are considered joinable when they are of the same type and\n// when the `isJoinable` predicate returns true for them or, if an\n// array of strings was passed, if their node type name is in that\n// array.\nexport function autoJoin(command, isJoinable) {\n  if (Array.isArray(isJoinable)) {\n    let types = isJoinable\n    isJoinable = node => types.indexOf(node.type.name) > -1\n  }\n  return (state, dispatch, view) => command(state, dispatch && wrapDispatchForJoin(dispatch, isJoinable), view)\n}\n\n// :: (...[(EditorState, ?(tr: Transaction), ?EditorView) \u2192 bool]) \u2192 (EditorState, ?(tr: Transaction), ?EditorView) \u2192 bool\n// Combine a number of command functions into a single function (which\n// calls them one by one until one returns true).\nexport function chainCommands(...commands) {\n  return function(state, dispatch, view) {\n    for (let i = 0; i < commands.length; i++)\n      if (commands[i](state, dispatch, view)) return true\n    return false\n  }\n}\n\nlet backspace = chainCommands(deleteSelection, joinBackward, selectNodeBackward)\nlet del = chainCommands(deleteSelection, joinForward, selectNodeForward)\n\n// :: Object\n// A basic keymap containing bindings not specific to any schema.\n// Binds the following keys (when multiple commands are listed, they\n// are chained with [`chainCommands`](#commands.chainCommands)):\n//\n// * **Enter** to `newlineInCode`, `createParagraphNear`, `liftEmptyBlock`, `splitBlock`\n// * **Mod-Enter** to `exitCode`\n// * **Backspace** and **Mod-Backspace** to `deleteSelection`, `joinBackward`, `selectNodeBackward`\n// * **Delete** and **Mod-Delete** to `deleteSelection`, `joinForward`, `selectNodeForward`\n// * **Mod-Delete** to `deleteSelection`, `joinForward`, `selectNodeForward`\n// * **Mod-a** to `selectAll`\nexport let pcBaseKeymap = {\n  \"Enter\": chainCommands(newlineInCode, createParagraphNear, liftEmptyBlock, splitBlock),\n  \"Mod-Enter\": exitCode,\n  \"Backspace\": backspace,\n  \"Mod-Backspace\": backspace,\n  \"Shift-Backspace\": backspace,\n  \"Delete\": del,\n  \"Mod-Delete\": del,\n  \"Mod-a\": selectAll\n}\n\n// :: Object\n// A copy of `pcBaseKeymap` that also binds **Ctrl-h** like Backspace,\n// **Ctrl-d** like Delete, **Alt-Backspace** like Ctrl-Backspace, and\n// **Ctrl-Alt-Backspace**, **Alt-Delete**, and **Alt-d** like\n// Ctrl-Delete.\nexport let macBaseKeymap = {\n  \"Ctrl-h\": pcBaseKeymap[\"Backspace\"],\n  \"Alt-Backspace\": pcBaseKeymap[\"Mod-Backspace\"],\n  \"Ctrl-d\": pcBaseKeymap[\"Delete\"],\n  \"Ctrl-Alt-Backspace\": pcBaseKeymap[\"Mod-Delete\"],\n  \"Alt-Delete\": pcBaseKeymap[\"Mod-Delete\"],\n  \"Alt-d\": pcBaseKeymap[\"Mod-Delete\"],\n  \"Ctrl-a\": selectTextblockStart,\n  \"Ctrl-e\": selectTextblockEnd\n}\nfor (let key in pcBaseKeymap) macBaseKeymap[key] = pcBaseKeymap[key]\n\n// declare global: os, navigator\nconst mac = typeof navigator != \"undefined\" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform)\n          : typeof os != \"undefined\" ? os.platform() == \"darwin\" : false\n\n// :: Object\n// Depending on the detected platform, this will hold\n// [`pcBasekeymap`](#commands.pcBaseKeymap) or\n// [`macBaseKeymap`](#commands.macBaseKeymap).\nexport let baseKeymap = mac ? macBaseKeymap : pcBaseKeymap\n", "var GOOD_LEAF_SIZE = 200;\n\n// :: class<T> A rope sequence is a persistent sequence data structure\n// that supports appending, prepending, and slicing without doing a\n// full copy. It is represented as a mostly-balanced tree.\nvar RopeSequence = function RopeSequence () {};\n\nRopeSequence.prototype.append = function append (other) {\n  if (!other.length) { return this }\n  other = RopeSequence.from(other);\n\n  return (!this.length && other) ||\n    (other.length < GOOD_LEAF_SIZE && this.leafAppend(other)) ||\n    (this.length < GOOD_LEAF_SIZE && other.leafPrepend(this)) ||\n    this.appendInner(other)\n};\n\n// :: (union<[T], RopeSequence<T>>) \u2192 RopeSequence<T>\n// Prepend an array or other rope to this one, returning a new rope.\nRopeSequence.prototype.prepend = function prepend (other) {\n  if (!other.length) { return this }\n  return RopeSequence.from(other).append(this)\n};\n\nRopeSequence.prototype.appendInner = function appendInner (other) {\n  return new Append(this, other)\n};\n\n// :: (?number, ?number) \u2192 RopeSequence<T>\n// Create a rope repesenting a sub-sequence of this rope.\nRopeSequence.prototype.slice = function slice (from, to) {\n    if ( from === void 0 ) from = 0;\n    if ( to === void 0 ) to = this.length;\n\n  if (from >= to) { return RopeSequence.empty }\n  return this.sliceInner(Math.max(0, from), Math.min(this.length, to))\n};\n\n// :: (number) \u2192 T\n// Retrieve the element at the given position from this rope.\nRopeSequence.prototype.get = function get (i) {\n  if (i < 0 || i >= this.length) { return undefined }\n  return this.getInner(i)\n};\n\n// :: ((element: T, index: number) \u2192 ?bool, ?number, ?number)\n// Call the given function for each element between the given\n// indices. This tends to be more efficient than looping over the\n// indices and calling `get`, because it doesn't have to descend the\n// tree for every element.\nRopeSequence.prototype.forEach = function forEach (f, from, to) {\n    if ( from === void 0 ) from = 0;\n    if ( to === void 0 ) to = this.length;\n\n  if (from <= to)\n    { this.forEachInner(f, from, to, 0); }\n  else\n    { this.forEachInvertedInner(f, from, to, 0); }\n};\n\n// :: ((element: T, index: number) \u2192 U, ?number, ?number) \u2192 [U]\n// Map the given functions over the elements of the rope, producing\n// a flat array.\nRopeSequence.prototype.map = function map (f, from, to) {\n    if ( from === void 0 ) from = 0;\n    if ( to === void 0 ) to = this.length;\n\n  var result = [];\n  this.forEach(function (elt, i) { return result.push(f(elt, i)); }, from, to);\n  return result\n};\n\n// :: (?union<[T], RopeSequence<T>>) \u2192 RopeSequence<T>\n// Create a rope representing the given array, or return the rope\n// itself if a rope was given.\nRopeSequence.from = function from (values) {\n  if (values instanceof RopeSequence) { return values }\n  return values && values.length ? new Leaf(values) : RopeSequence.empty\n};\n\nvar Leaf = /*@__PURE__*/(function (RopeSequence) {\n  function Leaf(values) {\n    RopeSequence.call(this);\n    this.values = values;\n  }\n\n  if ( RopeSequence ) Leaf.__proto__ = RopeSequence;\n  Leaf.prototype = Object.create( RopeSequence && RopeSequence.prototype );\n  Leaf.prototype.constructor = Leaf;\n\n  var prototypeAccessors = { length: { configurable: true },depth: { configurable: true } };\n\n  Leaf.prototype.flatten = function flatten () {\n    return this.values\n  };\n\n  Leaf.prototype.sliceInner = function sliceInner (from, to) {\n    if (from == 0 && to == this.length) { return this }\n    return new Leaf(this.values.slice(from, to))\n  };\n\n  Leaf.prototype.getInner = function getInner (i) {\n    return this.values[i]\n  };\n\n  Leaf.prototype.forEachInner = function forEachInner (f, from, to, start) {\n    for (var i = from; i < to; i++)\n      { if (f(this.values[i], start + i) === false) { return false } }\n  };\n\n  Leaf.prototype.forEachInvertedInner = function forEachInvertedInner (f, from, to, start) {\n    for (var i = from - 1; i >= to; i--)\n      { if (f(this.values[i], start + i) === false) { return false } }\n  };\n\n  Leaf.prototype.leafAppend = function leafAppend (other) {\n    if (this.length + other.length <= GOOD_LEAF_SIZE)\n      { return new Leaf(this.values.concat(other.flatten())) }\n  };\n\n  Leaf.prototype.leafPrepend = function leafPrepend (other) {\n    if (this.length + other.length <= GOOD_LEAF_SIZE)\n      { return new Leaf(other.flatten().concat(this.values)) }\n  };\n\n  prototypeAccessors.length.get = function () { return this.values.length };\n\n  prototypeAccessors.depth.get = function () { return 0 };\n\n  Object.defineProperties( Leaf.prototype, prototypeAccessors );\n\n  return Leaf;\n}(RopeSequence));\n\n// :: RopeSequence\n// The empty rope sequence.\nRopeSequence.empty = new Leaf([]);\n\nvar Append = /*@__PURE__*/(function (RopeSequence) {\n  function Append(left, right) {\n    RopeSequence.call(this);\n    this.left = left;\n    this.right = right;\n    this.length = left.length + right.length;\n    this.depth = Math.max(left.depth, right.depth) + 1;\n  }\n\n  if ( RopeSequence ) Append.__proto__ = RopeSequence;\n  Append.prototype = Object.create( RopeSequence && RopeSequence.prototype );\n  Append.prototype.constructor = Append;\n\n  Append.prototype.flatten = function flatten () {\n    return this.left.flatten().concat(this.right.flatten())\n  };\n\n  Append.prototype.getInner = function getInner (i) {\n    return i < this.left.length ? this.left.get(i) : this.right.get(i - this.left.length)\n  };\n\n  Append.prototype.forEachInner = function forEachInner (f, from, to, start) {\n    var leftLen = this.left.length;\n    if (from < leftLen &&\n        this.left.forEachInner(f, from, Math.min(to, leftLen), start) === false)\n      { return false }\n    if (to > leftLen &&\n        this.right.forEachInner(f, Math.max(from - leftLen, 0), Math.min(this.length, to) - leftLen, start + leftLen) === false)\n      { return false }\n  };\n\n  Append.prototype.forEachInvertedInner = function forEachInvertedInner (f, from, to, start) {\n    var leftLen = this.left.length;\n    if (from > leftLen &&\n        this.right.forEachInvertedInner(f, from - leftLen, Math.max(to, leftLen) - leftLen, start + leftLen) === false)\n      { return false }\n    if (to < leftLen &&\n        this.left.forEachInvertedInner(f, Math.min(from, leftLen), to, start) === false)\n      { return false }\n  };\n\n  Append.prototype.sliceInner = function sliceInner (from, to) {\n    if (from == 0 && to == this.length) { return this }\n    var leftLen = this.left.length;\n    if (to <= leftLen) { return this.left.slice(from, to) }\n    if (from >= leftLen) { return this.right.slice(from - leftLen, to - leftLen) }\n    return this.left.slice(from, leftLen).append(this.right.slice(0, to - leftLen))\n  };\n\n  Append.prototype.leafAppend = function leafAppend (other) {\n    var inner = this.right.leafAppend(other);\n    if (inner) { return new Append(this.left, inner) }\n  };\n\n  Append.prototype.leafPrepend = function leafPrepend (other) {\n    var inner = this.left.leafPrepend(other);\n    if (inner) { return new Append(inner, this.right) }\n  };\n\n  Append.prototype.appendInner = function appendInner (other) {\n    if (this.left.depth >= Math.max(this.right.depth, other.depth) + 1)\n      { return new Append(this.left, new Append(this.right, other)) }\n    return new Append(this, other)\n  };\n\n  return Append;\n}(RopeSequence));\n\nvar ropeSequence = RopeSequence;\n\nexport default ropeSequence;\n", "import RopeSequence from \"rope-sequence\"\nimport {Mapping} from \"prosemirror-transform\"\nimport {Plugin, PluginKey} from \"prosemirror-state\"\n\n// ProseMirror's history isn't simply a way to roll back to a previous\n// state, because ProseMirror supports applying changes without adding\n// them to the history (for example during collaboration).\n//\n// To this end, each 'Branch' (one for the undo history and one for\n// the redo history) keeps an array of 'Items', which can optionally\n// hold a step (an actual undoable change), and always hold a position\n// map (which is needed to move changes below them to apply to the\n// current document).\n//\n// An item that has both a step and a selection bookmark is the start\n// of an 'event' \u2014 a group of changes that will be undone or redone at\n// once. (It stores only the bookmark, since that way we don't have to\n// provide a document until the selection is actually applied, which\n// is useful when compressing.)\n\n// Used to schedule history compression\nconst max_empty_items = 500\n\nclass Branch {\n  constructor(items, eventCount) {\n    this.items = items\n    this.eventCount = eventCount\n  }\n\n  // : (EditorState, bool) \u2192 ?{transform: Transform, selection: ?SelectionBookmark, remaining: Branch}\n  // Pop the latest event off the branch's history and apply it\n  // to a document transform.\n  popEvent(state, preserveItems) {\n    if (this.eventCount == 0) return null\n\n    let end = this.items.length\n    for (;; end--) {\n      let next = this.items.get(end - 1)\n      if (next.selection) { --end; break }\n    }\n\n    let remap, mapFrom\n    if (preserveItems) {\n      remap = this.remapping(end, this.items.length)\n      mapFrom = remap.maps.length\n    }\n    let transform = state.tr\n    let selection, remaining\n    let addAfter = [], addBefore = []\n\n    this.items.forEach((item, i) => {\n      if (!item.step) {\n        if (!remap) {\n          remap = this.remapping(end, i + 1)\n          mapFrom = remap.maps.length\n        }\n        mapFrom--\n        addBefore.push(item)\n        return\n      }\n\n      if (remap) {\n        addBefore.push(new Item(item.map))\n        let step = item.step.map(remap.slice(mapFrom)), map\n\n        if (step && transform.maybeStep(step).doc) {\n          map = transform.mapping.maps[transform.mapping.maps.length - 1]\n          addAfter.push(new Item(map, null, null, addAfter.length + addBefore.length))\n        }\n        mapFrom--\n        if (map) remap.appendMap(map, mapFrom)\n      } else {\n        transform.maybeStep(item.step)\n      }\n\n      if (item.selection) {\n        selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection\n        remaining = new Branch(this.items.slice(0, end).append(addBefore.reverse().concat(addAfter)), this.eventCount - 1)\n        return false\n      }\n    }, this.items.length, 0)\n\n    return {remaining, transform, selection}\n  }\n\n  // : (Transform, ?SelectionBookmark, Object) \u2192 Branch\n  // Create a new branch with the given transform added.\n  addTransform(transform, selection, histOptions, preserveItems) {\n    let newItems = [], eventCount = this.eventCount\n    let oldItems = this.items, lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null\n\n    for (let i = 0; i < transform.steps.length; i++) {\n      let step = transform.steps[i].invert(transform.docs[i])\n      let item = new Item(transform.mapping.maps[i], step, selection), merged\n      if (merged = lastItem && lastItem.merge(item)) {\n        item = merged\n        if (i) newItems.pop()\n        else oldItems = oldItems.slice(0, oldItems.length - 1)\n      }\n      newItems.push(item)\n      if (selection) {\n        eventCount++\n        selection = null\n      }\n      if (!preserveItems) lastItem = item\n    }\n    let overflow = eventCount - histOptions.depth\n    if (overflow > DEPTH_OVERFLOW) {\n      oldItems = cutOffEvents(oldItems, overflow)\n      eventCount -= overflow\n    }\n    return new Branch(oldItems.append(newItems), eventCount)\n  }\n\n  remapping(from, to) {\n    let maps = new Mapping\n    this.items.forEach((item, i) => {\n      let mirrorPos = item.mirrorOffset != null && i - item.mirrorOffset >= from\n          ? maps.maps.length - item.mirrorOffset : null\n      maps.appendMap(item.map, mirrorPos)\n    }, from, to)\n    return maps\n  }\n\n  addMaps(array) {\n    if (this.eventCount == 0) return this\n    return new Branch(this.items.append(array.map(map => new Item(map))), this.eventCount)\n  }\n\n  // : (Transform, number)\n  // When the collab module receives remote changes, the history has\n  // to know about those, so that it can adjust the steps that were\n  // rebased on top of the remote changes, and include the position\n  // maps for the remote changes in its array of items.\n  rebased(rebasedTransform, rebasedCount) {\n    if (!this.eventCount) return this\n\n    let rebasedItems = [], start = Math.max(0, this.items.length - rebasedCount)\n\n    let mapping = rebasedTransform.mapping\n    let newUntil = rebasedTransform.steps.length\n    let eventCount = this.eventCount\n    this.items.forEach(item => { if (item.selection) eventCount-- }, start)\n\n    let iRebased = rebasedCount\n    this.items.forEach(item => {\n      let pos = mapping.getMirror(--iRebased)\n      if (pos == null) return\n      newUntil = Math.min(newUntil, pos)\n      let map = mapping.maps[pos]\n      if (item.step) {\n        let step = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos])\n        let selection = item.selection && item.selection.map(mapping.slice(iRebased + 1, pos))\n        if (selection) eventCount++\n        rebasedItems.push(new Item(map, step, selection))\n      } else {\n        rebasedItems.push(new Item(map))\n      }\n    }, start)\n\n    let newMaps = []\n    for (let i = rebasedCount; i < newUntil; i++)\n      newMaps.push(new Item(mapping.maps[i]))\n    let items = this.items.slice(0, start).append(newMaps).append(rebasedItems)\n    let branch = new Branch(items, eventCount)\n\n    if (branch.emptyItemCount() > max_empty_items)\n      branch = branch.compress(this.items.length - rebasedItems.length)\n    return branch\n  }\n\n  emptyItemCount() {\n    let count = 0\n    this.items.forEach(item => { if (!item.step) count++ })\n    return count\n  }\n\n  // Compressing a branch means rewriting it to push the air (map-only\n  // items) out. During collaboration, these naturally accumulate\n  // because each remote change adds one. The `upto` argument is used\n  // to ensure that only the items below a given level are compressed,\n  // because `rebased` relies on a clean, untouched set of items in\n  // order to associate old items with rebased steps.\n  compress(upto = this.items.length) {\n    let remap = this.remapping(0, upto), mapFrom = remap.maps.length\n    let items = [], events = 0\n    this.items.forEach((item, i) => {\n      if (i >= upto) {\n        items.push(item)\n        if (item.selection) events++\n      } else if (item.step) {\n        let step = item.step.map(remap.slice(mapFrom)), map = step && step.getMap()\n        mapFrom--\n        if (map) remap.appendMap(map, mapFrom)\n        if (step) {\n          let selection = item.selection && item.selection.map(remap.slice(mapFrom))\n          if (selection) events++\n          let newItem = new Item(map.invert(), step, selection), merged, last = items.length - 1\n          if (merged = items.length && items[last].merge(newItem))\n            items[last] = merged\n          else\n            items.push(newItem)\n        }\n      } else if (item.map) {\n        mapFrom--\n      }\n    }, this.items.length, 0)\n    return new Branch(RopeSequence.from(items.reverse()), events)\n  }\n}\n\nBranch.empty = new Branch(RopeSequence.empty, 0)\n\nfunction cutOffEvents(items, n) {\n  let cutPoint\n  items.forEach((item, i) => {\n    if (item.selection && (n-- == 0)) {\n      cutPoint = i\n      return false\n    }\n  })\n  return items.slice(cutPoint)\n}\n\nclass Item {\n  constructor(map, step, selection, mirrorOffset) {\n    // The (forward) step map for this item.\n    this.map = map\n    // The inverted step\n    this.step = step\n    // If this is non-null, this item is the start of a group, and\n    // this selection is the starting selection for the group (the one\n    // that was active before the first step was applied)\n    this.selection = selection\n    // If this item is the inverse of a previous mapping on the stack,\n    // this points at the inverse's offset\n    this.mirrorOffset = mirrorOffset\n  }\n\n  merge(other) {\n    if (this.step && other.step && !other.selection) {\n      let step = other.step.merge(this.step)\n      if (step) return new Item(step.getMap().invert(), step, this.selection)\n    }\n  }\n}\n\n// The value of the state field that tracks undo/redo history for that\n// state. Will be stored in the plugin state when the history plugin\n// is active.\nexport class HistoryState {\n  constructor(done, undone, prevRanges, prevTime) {\n    this.done = done\n    this.undone = undone\n    this.prevRanges = prevRanges\n    this.prevTime = prevTime\n  }\n}\n\nconst DEPTH_OVERFLOW = 20\n\n// : (HistoryState, EditorState, Transaction, Object)\n// Record a transformation in undo history.\nfunction applyTransaction(history, state, tr, options) {\n  let historyTr = tr.getMeta(historyKey), rebased\n  if (historyTr) return historyTr.historyState\n\n  if (tr.getMeta(closeHistoryKey)) history = new HistoryState(history.done, history.undone, null, 0)\n\n  let appended = tr.getMeta(\"appendedTransaction\")\n\n  if (tr.steps.length == 0) {\n    return history\n  } else if (appended && appended.getMeta(historyKey)) {\n    if (appended.getMeta(historyKey).redo)\n      return new HistoryState(history.done.addTransform(tr, null, options, mustPreserveItems(state)),\n                              history.undone, rangesFor(tr.mapping.maps[tr.steps.length - 1]), history.prevTime)\n    else\n      return new HistoryState(history.done, history.undone.addTransform(tr, null, options, mustPreserveItems(state)),\n                              null, history.prevTime)\n  } else if (tr.getMeta(\"addToHistory\") !== false && !(appended && appended.getMeta(\"addToHistory\") === false)) {\n    // Group transforms that occur in quick succession into one event.\n    let newGroup = history.prevTime == 0 || !appended && (history.prevTime < (tr.time || 0) - options.newGroupDelay ||\n                                                          !isAdjacentTo(tr, history.prevRanges))\n    let prevRanges = appended ? mapRanges(history.prevRanges, tr.mapping) : rangesFor(tr.mapping.maps[tr.steps.length - 1])\n    return new HistoryState(history.done.addTransform(tr, newGroup ? state.selection.getBookmark() : null,\n                                                      options, mustPreserveItems(state)),\n                            Branch.empty, prevRanges, tr.time)\n  } else if (rebased = tr.getMeta(\"rebased\")) {\n    // Used by the collab module to tell the history that some of its\n    // content has been rebased.\n    return new HistoryState(history.done.rebased(tr, rebased),\n                            history.undone.rebased(tr, rebased),\n                            mapRanges(history.prevRanges, tr.mapping), history.prevTime)\n  } else {\n    return new HistoryState(history.done.addMaps(tr.mapping.maps),\n                            history.undone.addMaps(tr.mapping.maps),\n                            mapRanges(history.prevRanges, tr.mapping), history.prevTime)\n  }\n}\n\nfunction isAdjacentTo(transform, prevRanges) {\n  if (!prevRanges) return false\n  if (!transform.docChanged) return true\n  let adjacent = false\n  transform.mapping.maps[0].forEach((start, end) => {\n    for (let i = 0; i < prevRanges.length; i += 2)\n      if (start <= prevRanges[i + 1] && end >= prevRanges[i])\n        adjacent = true\n  })\n  return adjacent\n}\n\nfunction rangesFor(map) {\n  let result = []\n  map.forEach((_from, _to, from, to) => result.push(from, to))\n  return result\n}\n\nfunction mapRanges(ranges, mapping) {\n  if (!ranges) return null\n  let result = []\n  for (let i = 0; i < ranges.length; i += 2) {\n    let from = mapping.map(ranges[i], 1), to = mapping.map(ranges[i + 1], -1)\n    if (from <= to) result.push(from, to)\n  }\n  return result\n}\n\n// : (HistoryState, EditorState, (tr: Transaction), bool)\n// Apply the latest event from one branch to the document and shift the event\n// onto the other branch.\nfunction histTransaction(history, state, dispatch, redo) {\n  let preserveItems = mustPreserveItems(state), histOptions = historyKey.get(state).spec.config\n  let pop = (redo ? history.undone : history.done).popEvent(state, preserveItems)\n  if (!pop) return\n\n  let selection = pop.selection.resolve(pop.transform.doc)\n  let added = (redo ? history.done : history.undone).addTransform(pop.transform, state.selection.getBookmark(),\n                                                                  histOptions, preserveItems)\n\n  let newHist = new HistoryState(redo ? added : pop.remaining, redo ? pop.remaining : added, null, 0)\n  dispatch(pop.transform.setSelection(selection).setMeta(historyKey, {redo, historyState: newHist}).scrollIntoView())\n}\n\nlet cachedPreserveItems = false, cachedPreserveItemsPlugins = null\n// Check whether any plugin in the given state has a\n// `historyPreserveItems` property in its spec, in which case we must\n// preserve steps exactly as they came in, so that they can be\n// rebased.\nfunction mustPreserveItems(state) {\n  let plugins = state.plugins\n  if (cachedPreserveItemsPlugins != plugins) {\n    cachedPreserveItems = false\n    cachedPreserveItemsPlugins = plugins\n    for (let i = 0; i < plugins.length; i++) if (plugins[i].spec.historyPreserveItems) {\n      cachedPreserveItems = true\n      break\n    }\n  }\n  return cachedPreserveItems\n}\n\n// :: (Transaction) \u2192 Transaction\n// Set a flag on the given transaction that will prevent further steps\n// from being appended to an existing history event (so that they\n// require a separate undo command to undo).\nexport function closeHistory(tr) {\n  return tr.setMeta(closeHistoryKey, true)\n}\n\nconst historyKey = new PluginKey(\"history\")\nconst closeHistoryKey = new PluginKey(\"closeHistory\")\n\n// :: (?Object) \u2192 Plugin\n// Returns a plugin that enables the undo history for an editor. The\n// plugin will track undo and redo stacks, which can be used with the\n// [`undo`](#history.undo) and [`redo`](#history.redo) commands.\n//\n// You can set an `\"addToHistory\"` [metadata\n// property](#state.Transaction.setMeta) of `false` on a transaction\n// to prevent it from being rolled back by undo.\n//\n//   config::-\n//   Supports the following configuration options:\n//\n//     depth:: ?number\n//     The amount of history events that are collected before the\n//     oldest events are discarded. Defaults to 100.\n//\n//     newGroupDelay:: ?number\n//     The delay between changes after which a new group should be\n//     started. Defaults to 500 (milliseconds). Note that when changes\n//     aren't adjacent, a new group is always started.\nexport function history(config) {\n  config = {depth: config && config.depth || 100,\n            newGroupDelay: config && config.newGroupDelay || 500}\n  return new Plugin({\n    key: historyKey,\n\n    state: {\n      init() {\n        return new HistoryState(Branch.empty, Branch.empty, null, 0)\n      },\n      apply(tr, hist, state) {\n        return applyTransaction(hist, state, tr, config)\n      }\n    },\n\n    config,\n\n    props: {\n      handleDOMEvents: {\n        beforeinput(view, e) {\n          let handled = e.inputType == \"historyUndo\" ? undo(view.state, view.dispatch) :\n              e.inputType == \"historyRedo\" ? redo(view.state, view.dispatch) : false\n          if (handled) e.preventDefault()\n          return handled\n        }\n      }\n    }\n  })\n}\n\n// :: (EditorState, ?(tr: Transaction)) \u2192 bool\n// A command function that undoes the last change, if any.\nexport function undo(state, dispatch) {\n  let hist = historyKey.getState(state)\n  if (!hist || hist.done.eventCount == 0) return false\n  if (dispatch) histTransaction(hist, state, dispatch, false)\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) \u2192 bool\n// A command function that redoes the last undone change, if any.\nexport function redo(state, dispatch) {\n  let hist = historyKey.getState(state)\n  if (!hist || hist.undone.eventCount == 0) return false\n  if (dispatch) histTransaction(hist, state, dispatch, true)\n  return true\n}\n\n// :: (EditorState) \u2192 number\n// The amount of undoable events available in a given state.\nexport function undoDepth(state) {\n  let hist = historyKey.getState(state)\n  return hist ? hist.done.eventCount : 0\n}\n\n// :: (EditorState) \u2192 number\n// The amount of redoable events available in a given editor state.\nexport function redoDepth(state) {\n  let hist = historyKey.getState(state)\n  return hist ? hist.undone.eventCount : 0\n}\n", "const SVG = \"http://www.w3.org/2000/svg\"\nconst XLINK = \"http://www.w3.org/1999/xlink\"\n\nconst prefix = \"ProseMirror-icon\"\n\nfunction hashPath(path) {\n  let hash = 0\n  for (let i = 0; i < path.length; i++)\n    hash = (((hash << 5) - hash) + path.charCodeAt(i)) | 0\n  return hash\n}\n\nexport function getIcon(icon) {\n  let node = document.createElement(\"div\")\n  node.className = prefix\n  if (icon.path) {\n    let name = \"pm-icon-\" + hashPath(icon.path).toString(16)\n    if (!document.getElementById(name)) buildSVG(name, icon)\n    let svg = node.appendChild(document.createElementNS(SVG, \"svg\"))\n    svg.style.width = (icon.width / icon.height) + \"em\"\n    let use = svg.appendChild(document.createElementNS(SVG, \"use\"))\n    use.setAttributeNS(XLINK, \"href\", /([^#]*)/.exec(document.location)[1] + \"#\" + name)\n  } else if (icon.dom) {\n    node.appendChild(icon.dom.cloneNode(true))\n  } else {\n    node.appendChild(document.createElement(\"span\")).textContent = icon.text || ''\n    if (icon.css) node.firstChild.style.cssText = icon.css\n  }\n  return node\n}\n\nfunction buildSVG(name, data) {\n  let collection = document.getElementById(prefix + \"-collection\")\n  if (!collection) {\n    collection = document.createElementNS(SVG, \"svg\")\n    collection.id = prefix + \"-collection\"\n    collection.style.display = \"none\"\n    document.body.insertBefore(collection, document.body.firstChild)\n  }\n  let sym = document.createElementNS(SVG, \"symbol\")\n  sym.id = name\n  sym.setAttribute(\"viewBox\", \"0 0 \" + data.width + \" \" + data.height)\n  let path = sym.appendChild(document.createElementNS(SVG, \"path\"))\n  path.setAttribute(\"d\", data.path)\n  collection.appendChild(sym)\n}\n", "import crel from \"crelt\"\nimport {lift, joinUp, selectParentNode, wrapIn, setBlockType} from \"prosemirror-commands\"\nimport {undo, redo} from \"prosemirror-history\"\n\nimport {getIcon} from \"./icons\"\n\nconst prefix = \"ProseMirror-menu\"\n\n// ::- An icon or label that, when clicked, executes a command.\nexport class MenuItem {\n  // :: (MenuItemSpec)\n  constructor(spec) {\n    // :: MenuItemSpec\n    // The spec used to create the menu item.\n    this.spec = spec\n  }\n\n  // :: (EditorView) \u2192 {dom: dom.Node, update: (EditorState) \u2192 bool}\n  // Renders the icon according to its [display\n  // spec](#menu.MenuItemSpec.display), and adds an event handler which\n  // executes the command when the representation is clicked.\n  render(view) {\n    let spec = this.spec\n    let dom = spec.render ? spec.render(view)\n        : spec.icon ? getIcon(spec.icon)\n        : spec.label ? crel(\"div\", null, translate(view, spec.label))\n        : null\n    if (!dom) throw new RangeError(\"MenuItem without icon or label property\")\n    if (spec.title) {\n      const title = (typeof spec.title === \"function\" ? spec.title(view.state) : spec.title)\n      dom.setAttribute(\"title\", translate(view, title))\n    }\n    if (spec.class) dom.classList.add(spec.class)\n    if (spec.css) dom.style.cssText += spec.css\n\n    dom.addEventListener(\"mousedown\", e => {\n      e.preventDefault()\n      if (!dom.classList.contains(prefix + \"-disabled\"))\n        spec.run(view.state, view.dispatch, view, e)\n    })\n\n    function update(state) {\n      if (spec.select) {\n        let selected = spec.select(state)\n        dom.style.display = selected ? \"\" : \"none\"\n        if (!selected) return false\n      }\n      let enabled = true\n      if (spec.enable) {\n        enabled = spec.enable(state) || false\n        setClass(dom, prefix + \"-disabled\", !enabled)\n      }\n      if (spec.active) {\n        let active = enabled && spec.active(state) || false\n        setClass(dom, prefix + \"-active\", active)\n      }\n      return true\n    }\n\n    return {dom, update}\n  }\n}\n\nfunction translate(view, text) {\n  return view._props.translate ? view._props.translate(text) : text\n}\n\n// MenuItemSpec:: interface\n// The configuration object passed to the `MenuItem` constructor.\n//\n//   run:: (EditorState, (Transaction), EditorView, dom.Event)\n//   The function to execute when the menu item is activated.\n//\n//   select:: ?(EditorState) \u2192 bool\n//   Optional function that is used to determine whether the item is\n//   appropriate at the moment. Deselected items will be hidden.\n//\n//   enable:: ?(EditorState) \u2192 bool\n//   Function that is used to determine if the item is enabled. If\n//   given and returning false, the item will be given a disabled\n//   styling.\n//\n//   active:: ?(EditorState) \u2192 bool\n//   A predicate function to determine whether the item is 'active' (for\n//   example, the item for toggling the strong mark might be active then\n//   the cursor is in strong text).\n//\n//   render:: ?(EditorView) \u2192 dom.Node\n//   A function that renders the item. You must provide either this,\n//   [`icon`](#menu.MenuItemSpec.icon), or [`label`](#MenuItemSpec.label).\n//\n//   icon:: ?Object\n//   Describes an icon to show for this item. The object may specify\n//   an SVG icon, in which case its `path` property should be an [SVG\n//   path\n//   spec](https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/d),\n//   and `width` and `height` should provide the viewbox in which that\n//   path exists. Alternatively, it may have a `text` property\n//   specifying a string of text that makes up the icon, with an\n//   optional `css` property giving additional CSS styling for the\n//   text. _Or_ it may contain `dom` property containing a DOM node.\n//\n//   label:: ?string\n//   Makes the item show up as a text label. Mostly useful for items\n//   wrapped in a [drop-down](#menu.Dropdown) or similar menu. The object\n//   should have a `label` property providing the text to display.\n//\n//   title:: ?union<string, (EditorState) \u2192 string>\n//   Defines DOM title (mouseover) text for the item.\n//\n//   class:: ?string\n//   Optionally adds a CSS class to the item's DOM representation.\n//\n//   css:: ?string\n//   Optionally adds a string of inline CSS to the item's DOM\n//   representation.\n\nlet lastMenuEvent = {time: 0, node: null}\nfunction markMenuEvent(e) {\n  lastMenuEvent.time = Date.now()\n  lastMenuEvent.node = e.target\n}\nfunction isMenuEvent(wrapper) {\n  return Date.now() - 100 < lastMenuEvent.time &&\n    lastMenuEvent.node && wrapper.contains(lastMenuEvent.node)\n}\n\n// ::- A drop-down menu, displayed as a label with a downwards-pointing\n// triangle to the right of it.\nexport class Dropdown {\n  // :: ([MenuElement], ?Object)\n  // Create a dropdown wrapping the elements. Options may include\n  // the following properties:\n  //\n  // **`label`**`: string`\n  //   : The label to show on the drop-down control.\n  //\n  // **`title`**`: string`\n  //   : Sets the\n  //     [`title`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/title)\n  //     attribute given to the menu control.\n  //\n  // **`class`**`: string`\n  //   : When given, adds an extra CSS class to the menu control.\n  //\n  // **`css`**`: string`\n  //   : When given, adds an extra set of CSS styles to the menu control.\n  constructor(content, options) {\n    this.options = options || {}\n    this.content = Array.isArray(content) ? content : [content]\n  }\n\n  // :: (EditorView) \u2192 {dom: dom.Node, update: (EditorState)}\n  // Render the dropdown menu and sub-items.\n  render(view) {\n    let content = renderDropdownItems(this.content, view)\n\n    let label = crel(\"div\", {class: prefix + \"-dropdown \" + (this.options.class || \"\"),\n                             style: this.options.css},\n                     translate(view, this.options.label))\n    if (this.options.title) label.setAttribute(\"title\", translate(view, this.options.title))\n    let wrap = crel(\"div\", {class: prefix + \"-dropdown-wrap\"}, label)\n    let open = null, listeningOnClose = null\n    let close = () => {\n      if (open && open.close()) {\n        open = null\n        window.removeEventListener(\"mousedown\", listeningOnClose)\n      }\n    }\n    label.addEventListener(\"mousedown\", e => {\n      e.preventDefault()\n      markMenuEvent(e)\n      if (open) {\n        close()\n      } else {\n        open = this.expand(wrap, content.dom)\n        window.addEventListener(\"mousedown\", listeningOnClose = () => {\n          if (!isMenuEvent(wrap)) close()\n        })\n      }\n    })\n\n    function update(state) {\n      let inner = content.update(state)\n      wrap.style.display = inner ? \"\" : \"none\"\n      return inner\n    }\n\n    return {dom: wrap, update}\n  }\n\n  expand(dom, items) {\n    let menuDOM = crel(\"div\", {class: prefix + \"-dropdown-menu \" + (this.options.class || \"\")}, items)\n\n    let done = false\n    function close() {\n      if (done) return\n      done = true\n      dom.removeChild(menuDOM)\n      return true\n    }\n    dom.appendChild(menuDOM)\n    return {close, node: menuDOM}\n  }\n}\n\nfunction renderDropdownItems(items, view) {\n  let rendered = [], updates = []\n  for (let i = 0; i < items.length; i++) {\n    let {dom, update} = items[i].render(view)\n    rendered.push(crel(\"div\", {class: prefix + \"-dropdown-item\"}, dom))\n    updates.push(update)\n  }\n  return {dom: rendered, update: combineUpdates(updates, rendered)}\n}\n\nfunction combineUpdates(updates, nodes) {\n  return state => {\n    let something = false\n    for (let i = 0; i < updates.length; i++) {\n      let up = updates[i](state)\n      nodes[i].style.display = up ? \"\" : \"none\"\n      if (up) something = true\n    }\n    return something\n  }\n}\n\n// ::- Represents a submenu wrapping a group of elements that start\n// hidden and expand to the right when hovered over or tapped.\nexport class DropdownSubmenu {\n  // :: ([MenuElement], ?Object)\n  // Creates a submenu for the given group of menu elements. The\n  // following options are recognized:\n  //\n  // **`label`**`: string`\n  //   : The label to show on the submenu.\n  constructor(content, options) {\n    this.options = options || {}\n    this.content = Array.isArray(content) ? content : [content]\n  }\n\n  // :: (EditorView) \u2192 {dom: dom.Node, update: (EditorState) \u2192 bool}\n  // Renders the submenu.\n  render(view) {\n    let items = renderDropdownItems(this.content, view)\n\n    let label = crel(\"div\", {class: prefix + \"-submenu-label\"}, translate(view, this.options.label))\n    let wrap = crel(\"div\", {class: prefix + \"-submenu-wrap\"}, label,\n                   crel(\"div\", {class: prefix + \"-submenu\"}, items.dom))\n    let listeningOnClose = null\n    label.addEventListener(\"mousedown\", e => {\n      e.preventDefault()\n      markMenuEvent(e)\n      setClass(wrap, prefix + \"-submenu-wrap-active\")\n      if (!listeningOnClose)\n        window.addEventListener(\"mousedown\", listeningOnClose = () => {\n          if (!isMenuEvent(wrap)) {\n            wrap.classList.remove(prefix + \"-submenu-wrap-active\")\n            window.removeEventListener(\"mousedown\", listeningOnClose)\n            listeningOnClose = null\n          }\n        })\n    })\n\n    function update(state) {\n      let inner = items.update(state)\n      wrap.style.display = inner ? \"\" : \"none\"\n      return inner\n    }\n    return {dom: wrap, update}\n  }\n}\n\n// :: (EditorView, [union<MenuElement, [MenuElement]>]) \u2192 {dom: ?dom.DocumentFragment, update: (EditorState) \u2192 bool}\n// Render the given, possibly nested, array of menu elements into a\n// document fragment, placing separators between them (and ensuring no\n// superfluous separators appear when some of the groups turn out to\n// be empty).\nexport function renderGrouped(view, content) {\n  let result = document.createDocumentFragment()\n  let updates = [], separators = []\n  for (let i = 0; i < content.length; i++) {\n    let items = content[i], localUpdates = [], localNodes = []\n    for (let j = 0; j < items.length; j++) {\n      let {dom, update} = items[j].render(view)\n      let span = crel(\"span\", {class: prefix + \"item\"}, dom)\n      result.appendChild(span)\n      localNodes.push(span)\n      localUpdates.push(update)\n    }\n    if (localUpdates.length) {\n      updates.push(combineUpdates(localUpdates, localNodes))\n      if (i < content.length - 1)\n        separators.push(result.appendChild(separator()))\n    }\n  }\n\n  function update(state) {\n    let something = false, needSep = false\n    for (let i = 0; i < updates.length; i++) {\n      let hasContent = updates[i](state)\n      if (i) separators[i - 1].style.display = needSep && hasContent ? \"\" : \"none\"\n      needSep = hasContent\n      if (hasContent) something = true\n    }\n    return something\n  }\n  return {dom: result, update}\n}\n\nfunction separator() {\n  return crel(\"span\", {class: prefix + \"separator\"})\n}\n\n// :: Object\n// A set of basic editor-related icons. Contains the properties\n// `join`, `lift`, `selectParentNode`, `undo`, `redo`, `strong`, `em`,\n// `code`, `link`, `bulletList`, `orderedList`, and `blockquote`, each\n// holding an object that can be used as the `icon` option to\n// `MenuItem`.\nexport const icons = {\n  join: {\n    width: 800, height: 900,\n    path: \"M0 75h800v125h-800z M0 825h800v-125h-800z M250 400h100v-100h100v100h100v100h-100v100h-100v-100h-100z\"\n  },\n  lift: {\n    width: 1024, height: 1024,\n    path: \"M219 310v329q0 7-5 12t-12 5q-8 0-13-5l-164-164q-5-5-5-13t5-13l164-164q5-5 13-5 7 0 12 5t5 12zM1024 749v109q0 7-5 12t-12 5h-987q-7 0-12-5t-5-12v-109q0-7 5-12t12-5h987q7 0 12 5t5 12zM1024 530v109q0 7-5 12t-12 5h-621q-7 0-12-5t-5-12v-109q0-7 5-12t12-5h621q7 0 12 5t5 12zM1024 310v109q0 7-5 12t-12 5h-621q-7 0-12-5t-5-12v-109q0-7 5-12t12-5h621q7 0 12 5t5 12zM1024 91v109q0 7-5 12t-12 5h-987q-7 0-12-5t-5-12v-109q0-7 5-12t12-5h987q7 0 12 5t5 12z\"\n  },\n  selectParentNode: {text: \"\\u2b1a\", css: \"font-weight: bold\"},\n  undo: {\n    width: 1024, height: 1024,\n    path: \"M761 1024c113-206 132-520-313-509v253l-384-384 384-384v248c534-13 594 472 313 775z\"\n  },\n  redo: {\n    width: 1024, height: 1024,\n    path: \"M576 248v-248l384 384-384 384v-253c-446-10-427 303-313 509-280-303-221-789 313-775z\"\n  },\n  strong: {\n    width: 805, height: 1024,\n    path: \"M317 869q42 18 80 18 214 0 214-191 0-65-23-102-15-25-35-42t-38-26-46-14-48-6-54-1q-41 0-57 5 0 30-0 90t-0 90q0 4-0 38t-0 55 2 47 6 38zM309 442q24 4 62 4 46 0 81-7t62-25 42-51 14-81q0-40-16-70t-45-46-61-24-70-8q-28 0-74 7 0 28 2 86t2 86q0 15-0 45t-0 45q0 26 0 39zM0 950l1-53q8-2 48-9t60-15q4-6 7-15t4-19 3-18 1-21 0-19v-37q0-561-12-585-2-4-12-8t-25-6-28-4-27-2-17-1l-2-47q56-1 194-6t213-5q13 0 39 0t38 0q40 0 78 7t73 24 61 40 42 59 16 78q0 29-9 54t-22 41-36 32-41 25-48 22q88 20 146 76t58 141q0 57-20 102t-53 74-78 48-93 27-100 8q-25 0-75-1t-75-1q-60 0-175 6t-132 6z\"\n  },\n  em: {\n    width: 585, height: 1024,\n    path: \"M0 949l9-48q3-1 46-12t63-21q16-20 23-57 0-4 35-165t65-310 29-169v-14q-13-7-31-10t-39-4-33-3l10-58q18 1 68 3t85 4 68 1q27 0 56-1t69-4 56-3q-2 22-10 50-17 5-58 16t-62 19q-4 10-8 24t-5 22-4 26-3 24q-15 84-50 239t-44 203q-1 5-7 33t-11 51-9 47-3 32l0 10q9 2 105 17-1 25-9 56-6 0-18 0t-18 0q-16 0-49-5t-49-5q-78-1-117-1-29 0-81 5t-69 6z\"\n  },\n  code: {\n    width: 896, height: 1024,\n    path: \"M608 192l-96 96 224 224-224 224 96 96 288-320-288-320zM288 192l-288 320 288 320 96-96-224-224 224-224-96-96z\"\n  },\n  link: {\n    width: 951, height: 1024,\n    path: \"M832 694q0-22-16-38l-118-118q-16-16-38-16-24 0-41 18 1 1 10 10t12 12 8 10 7 14 2 15q0 22-16 38t-38 16q-8 0-15-2t-14-7-10-8-12-12-10-10q-18 17-18 41 0 22 16 38l117 118q15 15 38 15 22 0 38-14l84-83q16-16 16-38zM430 292q0-22-16-38l-117-118q-16-16-38-16-22 0-38 15l-84 83q-16 16-16 38 0 22 16 38l118 118q15 15 38 15 24 0 41-17-1-1-10-10t-12-12-8-10-7-14-2-15q0-22 16-38t38-16q8 0 15 2t14 7 10 8 12 12 10 10q18-17 18-41zM941 694q0 68-48 116l-84 83q-47 47-116 47-69 0-116-48l-117-118q-47-47-47-116 0-70 50-119l-50-50q-49 50-118 50-68 0-116-48l-118-118q-48-48-48-116t48-116l84-83q47-47 116-47 69 0 116 48l117 118q47 47 47 116 0 70-50 119l50 50q49-50 118-50 68 0 116 48l118 118q48 48 48 116z\"\n  },\n  bulletList: {\n    width: 768, height: 896,\n    path: \"M0 512h128v-128h-128v128zM0 256h128v-128h-128v128zM0 768h128v-128h-128v128zM256 512h512v-128h-512v128zM256 256h512v-128h-512v128zM256 768h512v-128h-512v128z\"\n  },\n  orderedList: {\n    width: 768, height: 896,\n    path: \"M320 512h448v-128h-448v128zM320 768h448v-128h-448v128zM320 128v128h448v-128h-448zM79 384h78v-256h-36l-85 23v50l43-2v185zM189 590c0-36-12-78-96-78-33 0-64 6-83 16l1 66c21-10 42-15 67-15s32 11 32 28c0 26-30 58-110 112v50h192v-67l-91 2c49-30 87-66 87-113l1-1z\"\n  },\n  blockquote: {\n    width: 640, height: 896,\n    path: \"M0 448v256h256v-256h-128c0 0 0-128 128-128v-128c0 0-256 0-256 256zM640 320v-128c0 0-256 0-256 256v256h256v-256h-128c0 0 0-128 128-128z\"\n  }\n}\n\n// :: MenuItem\n// Menu item for the `joinUp` command.\nexport const joinUpItem = new MenuItem({\n  title: \"Join with above block\",\n  run: joinUp,\n  select: state => joinUp(state),\n  icon: icons.join\n})\n\n// :: MenuItem\n// Menu item for the `lift` command.\nexport const liftItem = new MenuItem({\n  title: \"Lift out of enclosing block\",\n  run: lift,\n  select: state => lift(state),\n  icon: icons.lift\n})\n\n// :: MenuItem\n// Menu item for the `selectParentNode` command.\nexport const selectParentNodeItem = new MenuItem({\n  title: \"Select parent node\",\n  run: selectParentNode,\n  select: state => selectParentNode(state),\n  icon: icons.selectParentNode\n})\n\n// :: MenuItem\n// Menu item for the `undo` command.\nexport let undoItem = new MenuItem({\n  title: \"Undo last change\",\n  run: undo,\n  enable: state => undo(state),\n  icon: icons.undo\n})\n\n// :: MenuItem\n// Menu item for the `redo` command.\nexport let redoItem = new MenuItem({\n  title: \"Redo last undone change\",\n  run: redo,\n  enable: state => redo(state),\n  icon: icons.redo\n})\n\n// :: (NodeType, Object) \u2192 MenuItem\n// Build a menu item for wrapping the selection in a given node type.\n// Adds `run` and `select` properties to the ones present in\n// `options`. `options.attrs` may be an object or a function.\nexport function wrapItem(nodeType, options) {\n  let passedOptions = {\n    run(state, dispatch) {\n      // FIXME if (options.attrs instanceof Function) options.attrs(state, attrs => wrapIn(nodeType, attrs)(state))\n      return wrapIn(nodeType, options.attrs)(state, dispatch)\n    },\n    select(state) {\n      return wrapIn(nodeType, options.attrs instanceof Function ? null : options.attrs)(state)\n    }\n  }\n  for (let prop in options) passedOptions[prop] = options[prop]\n  return new MenuItem(passedOptions)\n}\n\n// :: (NodeType, Object) \u2192 MenuItem\n// Build a menu item for changing the type of the textblock around the\n// selection to the given type. Provides `run`, `active`, and `select`\n// properties. Others must be given in `options`. `options.attrs` may\n// be an object to provide the attributes for the textblock node.\nexport function blockTypeItem(nodeType, options) {\n  let command = setBlockType(nodeType, options.attrs)\n  let passedOptions = {\n    run: command,\n    enable(state) { return command(state) },\n    active(state) {\n      let {$from, to, node} = state.selection\n      if (node) return node.hasMarkup(nodeType, options.attrs)\n      return to <= $from.end() && $from.parent.hasMarkup(nodeType, options.attrs)\n    }\n  }\n  for (let prop in options) passedOptions[prop] = options[prop]\n  return new MenuItem(passedOptions)\n}\n\n// Work around classList.toggle being broken in IE11\nfunction setClass(dom, cls, on) {\n  if (on) dom.classList.add(cls)\n  else dom.classList.remove(cls)\n}\n", "import crel from \"crelt\"\nimport {Plugin} from \"prosemirror-state\"\n\nimport {renderGrouped} from \"./menu\"\n\nconst prefix = \"ProseMirror-menubar\"\n\nfunction isIOS() {\n  if (typeof navigator == \"undefined\") return false\n  let agent = navigator.userAgent\n  return !/Edge\\/\\d/.test(agent) && /AppleWebKit/.test(agent) && /Mobile\\/\\w+/.test(agent)\n}\n\n// :: (Object) \u2192 Plugin\n// A plugin that will place a menu bar above the editor. Note that\n// this involves wrapping the editor in an additional `<div>`.\n//\n//   options::-\n//   Supports the following options:\n//\n//     content:: [[MenuElement]]\n//     Provides the content of the menu, as a nested array to be\n//     passed to `renderGrouped`.\n//\n//     floating:: ?bool\n//     Determines whether the menu floats, i.e. whether it sticks to\n//     the top of the viewport when the editor is partially scrolled\n//     out of view.\nexport function menuBar(options) {\n  return new Plugin({\n    view(editorView) { return new MenuBarView(editorView, options) }\n  })\n}\n\nclass MenuBarView {\n  constructor(editorView, options) {\n    this.editorView = editorView\n    this.options = options\n\n    this.wrapper = crel(\"div\", {class: prefix + \"-wrapper\"})\n    this.menu = this.wrapper.appendChild(crel(\"div\", {class: prefix}))\n    this.menu.className = prefix\n    this.spacer = null\n\n    editorView.dom.parentNode.replaceChild(this.wrapper, editorView.dom)\n    this.wrapper.appendChild(editorView.dom)\n\n    this.maxHeight = 0\n    this.widthForMaxHeight = 0\n    this.floating = false\n\n    let {dom, update} = renderGrouped(this.editorView, this.options.content)\n    this.contentUpdate = update\n    this.menu.appendChild(dom)\n    this.update()\n\n    if (options.floating && !isIOS()) {\n      this.updateFloat()\n      let potentialScrollers = getAllWrapping(this.wrapper)\n      this.scrollFunc = (e) => {\n        let root = this.editorView.root\n        if (!(root.body || root).contains(this.wrapper)) {\n            potentialScrollers.forEach(el => el.removeEventListener(\"scroll\", this.scrollFunc))\n        } else {\n            this.updateFloat(e.target.getBoundingClientRect && e.target)\n        }\n      }\n      potentialScrollers.forEach(el => el.addEventListener('scroll', this.scrollFunc))\n    }\n  }\n\n  update() {\n    this.contentUpdate(this.editorView.state)\n\n    if (this.floating) {\n      this.updateScrollCursor()\n    } else {\n      if (this.menu.offsetWidth != this.widthForMaxHeight) {\n        this.widthForMaxHeight = this.menu.offsetWidth\n        this.maxHeight = 0\n      }\n      if (this.menu.offsetHeight > this.maxHeight) {\n        this.maxHeight = this.menu.offsetHeight\n        this.menu.style.minHeight = this.maxHeight + \"px\"\n      }\n    }\n  }\n\n  updateScrollCursor() {\n    let selection = this.editorView.root.getSelection()\n    if (!selection.focusNode) return\n    let rects = selection.getRangeAt(0).getClientRects()\n    let selRect = rects[selectionIsInverted(selection) ? 0 : rects.length - 1]\n    if (!selRect) return\n    let menuRect = this.menu.getBoundingClientRect()\n    if (selRect.top < menuRect.bottom && selRect.bottom > menuRect.top) {\n      let scrollable = findWrappingScrollable(this.wrapper)\n      if (scrollable) scrollable.scrollTop -= (menuRect.bottom - selRect.top)\n    }\n  }\n\n  updateFloat(scrollAncestor) {\n    let parent = this.wrapper, editorRect = parent.getBoundingClientRect(),\n        top = scrollAncestor ? Math.max(0, scrollAncestor.getBoundingClientRect().top) : 0\n\n    if (this.floating) {\n      if (editorRect.top >= top || editorRect.bottom < this.menu.offsetHeight + 10) {\n        this.floating = false\n        this.menu.style.position = this.menu.style.left = this.menu.style.top = this.menu.style.width = \"\"\n        this.menu.style.display = \"\"\n        this.spacer.parentNode.removeChild(this.spacer)\n        this.spacer = null\n      } else {\n        let border = (parent.offsetWidth - parent.clientWidth) / 2\n        this.menu.style.left = (editorRect.left + border) + \"px\"\n        this.menu.style.display = (editorRect.top > window.innerHeight ? \"none\" : \"\")\n        if (scrollAncestor) this.menu.style.top = top + \"px\"\n      }\n    } else {\n      if (editorRect.top < top && editorRect.bottom >= this.menu.offsetHeight + 10) {\n        this.floating = true\n        let menuRect = this.menu.getBoundingClientRect()\n        this.menu.style.left = menuRect.left + \"px\"\n        this.menu.style.width = menuRect.width + \"px\"\n        if (scrollAncestor) this.menu.style.top = top + \"px\"\n        this.menu.style.position = \"fixed\"\n        this.spacer = crel(\"div\", {class: prefix + \"-spacer\", style: `height: ${menuRect.height}px`})\n        parent.insertBefore(this.spacer, this.menu)\n      }\n    }\n  }\n\n  destroy() {\n    if (this.wrapper.parentNode)\n      this.wrapper.parentNode.replaceChild(this.editorView.dom, this.wrapper)\n  }\n}\n\n// Not precise, but close enough\nfunction selectionIsInverted(selection) {\n  if (selection.anchorNode == selection.focusNode) return selection.anchorOffset > selection.focusOffset\n  return selection.anchorNode.compareDocumentPosition(selection.focusNode) == Node.DOCUMENT_POSITION_FOLLOWING\n}\n\nfunction findWrappingScrollable(node) {\n  for (let cur = node.parentNode; cur; cur = cur.parentNode)\n    if (cur.scrollHeight > cur.clientHeight) return cur\n}\n\nfunction getAllWrapping(node) {\n    let res = [window]\n    for (let cur = node.parentNode; cur; cur = cur.parentNode)\n        res.push(cur)\n    return res\n}\n", "import { icons as prosemirrorIcons } from 'prosemirror-menu';\n\nexport const icons = {\n  ...prosemirrorIcons,\n  strikethrough: {\n    'width': 22,\n    'height': 22,\n    'path': 'M15.6 8.5c-.5-.7-1-1.1-1.3-1.3c-.6-.4-1.3-.6-2-.6c-2.7 0-2.8 1.7-2.8 2.1c0 1.6 1.8 2 3.2 2.3c4.4.9 4.6 2.8 4.6 3.9c0 1.4-.7 4.1-5 4.1A6.2 6.2 0 017 16.4l1.5-1.1c.4.6 1.6 2 3.7 2c1.6 0 2.5-.4 3-1.2c.4-.8.3-2-.8-2.6c-.7-.4-1.6-.7-2.9-1c-1-.2-3.9-.8-3.9-3.6C7.6 6 10.3 5 12.4 5c2.9 0 4.2 1.6 4.7 2.4l-1.5 1.1zM5 11h14a1 1 0 010 2H5a1 1 0 010-2z'\n  },\n  underline: {\n    'width': 22,\n    'height': 20,\n    'path': 'M16 5c.6 0 1 .4 1 1v5.5a4 4 0 01-.4 1.8l-1 1.4a5.3 5.3 0 01-5.5 1a5 5 0 01-1.6-1c-.5-.4-.8-.9-1.1-1.4a4 4 0 01-.4-1.8V6c0-.6.4-1 1-1s1 .4 1 1v5.5c0 .3 0 .6.2 1l.6.7a3.3 3.3 0 002.2.8a3.4 3.4 0 002.2-.8c.3-.2.4-.5.6-.8l.2-.9V6c0-.6.4-1 1-1zM8 17h8c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 010-2z'\n  }\n};\n", "/**\n * Toggle color text for cursor OR selected element.\n */\nexport function toggleMultiMarks(markType, attrs) {\n  return function(state, dispatch) {\n    let {empty, $cursor, ranges} = state.selection;\n    if (empty && !$cursor) return false;\n\n    if (dispatch) {\n      if ($cursor) {\n        if (markType.isInSet(state.storedMarks || $cursor.marks())) {\n          dispatch(state.tr.removeStoredMark(markType));\n        }\n\n        if (attrs) {\n          dispatch(state.tr.addStoredMark(markType.create(attrs)));\n        }\n      } else {\n        let has = false, tr = state.tr;\n        for (let i = 0; !has && i < ranges.length; i++) {\n          let {$from, $to} = ranges[i];\n          has = state.doc.rangeHasMark($from.pos, $to.pos, markType);\n        }\n        for (let i = 0; i < ranges.length; i++) {\n          let { $from, $to } = ranges[i];\n          let from = $from.pos, to = $to.pos, start = $from.nodeAfter, end = $to.nodeBefore;\n          let spaceStart = start && start.isText ? /^\\s*/.exec(start.text)[0].length : 0;\n          let spaceEnd = end && end.isText ? /\\s*$/.exec(end.text)[0].length : 0;\n          if (from + spaceStart < to) { from += spaceStart; to -= spaceEnd; }\n          if (attrs) {\n            tr.addMark(from, to, markType.create(attrs));\n          } else {\n            tr.removeMark(from, to, markType);\n          }\n        }\n\n        dispatch(tr.scrollIntoView());\n      }\n    }\n    return true;\n  };\n}\n\n/**\n * Returns a function that will generate Marks for Prosemirror schema.\n */\nexport const generateExProsemirrorMarks = ( marksSelection, marks ) => {\n  const result = {};\n\n  marksSelection.map((/** @type {Object} */ element) => {\n    if (marks[element.type]) {\n      result[element.type] = { ...marks[element.type], config: element };\n    }\n  });\n\n  return result;\n};\n", "import { nodes } from 'prosemirror-schema-basic';\nimport { generateExProsemirorBlocks } from './helpers';\n\nimport { menuHelper } from '../menu';\n\nconst paragraph = {\n  ...nodes.paragraph,\n  generateMenuItem: menuHelper.generateParagraphItem\n};\n\nconst heading = {\n  ...nodes.heading,\n  generateMenuItem: menuHelper.generateHeadingItem\n};\n\nconst html = {\n  inline: true,\n  attrs: {\n    html: {default: null}\n  },\n  group: 'inline',\n  draggable: false,\n  parseDOM: [{tag: 'div[html]', getAttrs(dom) {\n    return {\n      html: dom.getAttribute('html'),\n    };\n  }}],\n  toDOM(node) {\n    let {html} = node.attrs;\n    let myDom = document.createElement('div');\n    myDom.innerHTML = html;\n    return myDom;\n  },\n  generateMenuItem: menuHelper.generateHTMLItem\n};\n\nconst image = {\n  ...nodes.image,\n  inline: false,\n  group: 'block',\n  generateMenuItem: menuHelper.generateMediaMenu\n};\n\nexport const blocks = {\n  doc: nodes.doc,\n  text: nodes.text,\n  hard_break: nodes.hard_break,\n  paragraph,\n  heading,\n  image,\n  html\n};\n\n/**\n * @param {{blocksSelection: Object, blocks: Object[], inline: boolean}} opts\n */\nexport const generateSchemablocks = ({ blocksSelection, blocks, inline }) => (\n  generateExProsemirorBlocks(blocksSelection, blocks, inline)\n);\n", "/**\n * @param {Object} blocks\n * @param {Boolean} inline\n\n */\nfunction inlineDoc(blocks, inline) {\n  return inline ? { content: 'block?' } : blocks.doc;\n}\n\n/**\n * @param {Object} blocksSelection\n * @param {Object} blocks\n * @param {Boolean} inline\n */\nexport const generateExProsemirorBlocks = (blocksSelection, blocks, inline) => {\n  const map = {\n    text: blocks.text,\n    doc: inlineDoc(blocks, inline)\n  };\n\n  blocksSelection.map((/** @type {Object} */ element) => {\n    if (blocks[element.type]) {\n      map[element.type] = { ...blocks[element.type], config: element };\n    }\n  });\n\n  return map;\n};\n", "import { exampleSetup as pluginFunc } from 'prosemirror-example-setup';\nimport schemaFunc from '../prosemirror/schema';\nimport exProsemirror from '../index';\n\nconst ExProsemirrorHooks = {};\n\nExProsemirrorHooks.MountProseMirror = {\n  mounted() {\n    exProsemirror.init(this.el, { schemaFunc, pluginFunc });\n  },\n  updated() {\n    // transforms the following schema rules\n    exProsemirror.init(this.el, { schemaFunc, pluginFunc });\n  },\n};\n\nexport { ExProsemirrorHooks };\n", "export var base = {\n  8: \"Backspace\",\n  9: \"Tab\",\n  10: \"Enter\",\n  12: \"NumLock\",\n  13: \"Enter\",\n  16: \"Shift\",\n  17: \"Control\",\n  18: \"Alt\",\n  20: \"CapsLock\",\n  27: \"Escape\",\n  32: \" \",\n  33: \"PageUp\",\n  34: \"PageDown\",\n  35: \"End\",\n  36: \"Home\",\n  37: \"ArrowLeft\",\n  38: \"ArrowUp\",\n  39: \"ArrowRight\",\n  40: \"ArrowDown\",\n  44: \"PrintScreen\",\n  45: \"Insert\",\n  46: \"Delete\",\n  59: \";\",\n  61: \"=\",\n  91: \"Meta\",\n  92: \"Meta\",\n  106: \"*\",\n  107: \"+\",\n  108: \",\",\n  109: \"-\",\n  110: \".\",\n  111: \"/\",\n  144: \"NumLock\",\n  145: \"ScrollLock\",\n  160: \"Shift\",\n  161: \"Shift\",\n  162: \"Control\",\n  163: \"Control\",\n  164: \"Alt\",\n  165: \"Alt\",\n  173: \"-\",\n  186: \";\",\n  187: \"=\",\n  188: \",\",\n  189: \"-\",\n  190: \".\",\n  191: \"/\",\n  192: \"`\",\n  219: \"[\",\n  220: \"\\\\\",\n  221: \"]\",\n  222: \"'\",\n  229: \"q\"\n}\n\nexport var shift = {\n  48: \")\",\n  49: \"!\",\n  50: \"@\",\n  51: \"#\",\n  52: \"$\",\n  53: \"%\",\n  54: \"^\",\n  55: \"&\",\n  56: \"*\",\n  57: \"(\",\n  59: \":\",\n  61: \"+\",\n  173: \"_\",\n  186: \":\",\n  187: \"+\",\n  188: \"<\",\n  189: \"_\",\n  190: \">\",\n  191: \"?\",\n  192: \"~\",\n  219: \"{\",\n  220: \"|\",\n  221: \"}\",\n  222: \"\\\"\",\n  229: \"Q\"\n}\n\nvar chrome = typeof navigator != \"undefined\" && /Chrome\\/(\\d+)/.exec(navigator.userAgent)\nvar safari = typeof navigator != \"undefined\" && /Apple Computer/.test(navigator.vendor)\nvar gecko = typeof navigator != \"undefined\" && /Gecko\\/\\d+/.test(navigator.userAgent)\nvar mac = typeof navigator != \"undefined\" && /Mac/.test(navigator.platform)\nvar ie = typeof navigator != \"undefined\" && /MSIE \\d|Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(navigator.userAgent)\nvar brokenModifierNames = chrome && (mac || +chrome[1] < 57) || gecko && mac\n\n// Fill in the digit keys\nfor (var i = 0; i < 10; i++) base[48 + i] = base[96 + i] = String(i)\n\n// The function keys\nfor (var i = 1; i <= 24; i++) base[i + 111] = \"F\" + i\n\n// And the alphabetic keys\nfor (var i = 65; i <= 90; i++) {\n  base[i] = String.fromCharCode(i + 32)\n  shift[i] = String.fromCharCode(i)\n}\n\n// For each code that doesn't have a shift-equivalent, copy the base name\nfor (var code in base) if (!shift.hasOwnProperty(code)) shift[code] = base[code]\n\nexport function keyName(event) {\n  // Don't trust event.key in Chrome when there are modifiers until\n  // they fix https://bugs.chromium.org/p/chromium/issues/detail?id=633838\n  var ignoreKey = brokenModifierNames && (event.ctrlKey || event.altKey || event.metaKey) ||\n    (safari || ie) && event.shiftKey && event.key && event.key.length == 1\n  var name = (!ignoreKey && event.key) ||\n    (event.shiftKey ? shift : base)[event.keyCode] ||\n    event.key || \"Unidentified\"\n  // Edge sometimes produces wrong names (Issue #3)\n  if (name == \"Esc\") name = \"Escape\"\n  if (name == \"Del\") name = \"Delete\"\n  // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8860571/\n  if (name == \"Left\") name = \"ArrowLeft\"\n  if (name == \"Up\") name = \"ArrowUp\"\n  if (name == \"Right\") name = \"ArrowRight\"\n  if (name == \"Down\") name = \"ArrowDown\"\n  return name\n}\n", "import {base, keyName} from \"w3c-keyname\"\nimport {Plugin} from \"prosemirror-state\"\n\n// declare global: navigator\n\nconst mac = typeof navigator != \"undefined\" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : false\n\nfunction normalizeKeyName(name) {\n  let parts = name.split(/-(?!$)/), result = parts[parts.length - 1]\n  if (result == \"Space\") result = \" \"\n  let alt, ctrl, shift, meta\n  for (let i = 0; i < parts.length - 1; i++) {\n    let mod = parts[i]\n    if (/^(cmd|meta|m)$/i.test(mod)) meta = true\n    else if (/^a(lt)?$/i.test(mod)) alt = true\n    else if (/^(c|ctrl|control)$/i.test(mod)) ctrl = true\n    else if (/^s(hift)?$/i.test(mod)) shift = true\n    else if (/^mod$/i.test(mod)) { if (mac) meta = true; else ctrl = true }\n    else throw new Error(\"Unrecognized modifier name: \" + mod)\n  }\n  if (alt) result = \"Alt-\" + result\n  if (ctrl) result = \"Ctrl-\" + result\n  if (meta) result = \"Meta-\" + result\n  if (shift) result = \"Shift-\" + result\n  return result\n}\n\nfunction normalize(map) {\n  let copy = Object.create(null)\n  for (let prop in map) copy[normalizeKeyName(prop)] = map[prop]\n  return copy\n}\n\nfunction modifiers(name, event, shift) {\n  if (event.altKey) name = \"Alt-\" + name\n  if (event.ctrlKey) name = \"Ctrl-\" + name\n  if (event.metaKey) name = \"Meta-\" + name\n  if (shift !== false && event.shiftKey) name = \"Shift-\" + name\n  return name\n}\n\n// :: (Object) \u2192 Plugin\n// Create a keymap plugin for the given set of bindings.\n//\n// Bindings should map key names to [command](#commands)-style\n// functions, which will be called with `(EditorState, dispatch,\n// EditorView)` arguments, and should return true when they've handled\n// the key. Note that the view argument isn't part of the command\n// protocol, but can be used as an escape hatch if a binding needs to\n// directly interact with the UI.\n//\n// Key names may be strings like `\"Shift-Ctrl-Enter\"`\u2014a key\n// identifier prefixed with zero or more modifiers. Key identifiers\n// are based on the strings that can appear in\n// [`KeyEvent.key`](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key).\n// Use lowercase letters to refer to letter keys (or uppercase letters\n// if you want shift to be held). You may use `\"Space\"` as an alias\n// for the `\" \"` name.\n//\n// Modifiers can be given in any order. `Shift-` (or `s-`), `Alt-` (or\n// `a-`), `Ctrl-` (or `c-` or `Control-`) and `Cmd-` (or `m-` or\n// `Meta-`) are recognized. For characters that are created by holding\n// shift, the `Shift-` prefix is implied, and should not be added\n// explicitly.\n//\n// You can use `Mod-` as a shorthand for `Cmd-` on Mac and `Ctrl-` on\n// other platforms.\n//\n// You can add multiple keymap plugins to an editor. The order in\n// which they appear determines their precedence (the ones early in\n// the array get to dispatch first).\nexport function keymap(bindings) {\n  return new Plugin({props: {handleKeyDown: keydownHandler(bindings)}})\n}\n\n// :: (Object) \u2192 (view: EditorView, event: dom.Event) \u2192 bool\n// Given a set of bindings (using the same format as\n// [`keymap`](#keymap.keymap)), return a [keydown\n// handler](#view.EditorProps.handleKeyDown) that handles them.\nexport function keydownHandler(bindings) {\n  let map = normalize(bindings)\n  return function(view, event) {\n    let name = keyName(event), isChar = name.length == 1 && name != \" \", baseName\n    let direct = map[modifiers(name, event, !isChar)]\n    if (direct && direct(view.state, view.dispatch, view)) return true\n    if (isChar && (event.shiftKey || event.altKey || event.metaKey || name.charCodeAt(0) > 127) &&\n        (baseName = base[event.keyCode]) && baseName != name) {\n      // Try falling back to the keyCode when there's a modifier\n      // active or the character produced isn't ASCII, and our table\n      // produces a different name from the the keyCode. See #668,\n      // #1060\n      let fromCode = map[modifiers(baseName, event, true)]\n      if (fromCode && fromCode(view.state, view.dispatch, view)) return true\n    } else if (isChar && event.shiftKey) {\n      // Otherwise, if shift is active, also try the binding with the\n      // Shift- prefix enabled. See #997\n      let withShift = map[modifiers(name, event, true)]\n      if (withShift && withShift(view.state, view.dispatch, view)) return true\n    }\n    return false\n  }\n}\n", "import { keymap } from 'prosemirror-keymap';\nimport { baseKeymap, chainCommands, exitCode } from 'prosemirror-commands';\n\nfunction insertHardBreak(state, dispatch) {\n  const br = state.schema.nodes.hard_break;\n\n  dispatch(state.tr.replaceSelectionWith(br.create()).scrollIntoView());\n}\n\nconst hardBreakKeymap = {\n  'Shift-Enter': chainCommands(exitCode, insertHardBreak),\n};\n\nexport { keymap, baseKeymap, hardBreakKeymap };\n", "import ExEditorView from './ExEditorView';\n\nexport { ExProsemirrorHooks } from './hooks';\nexport { blocks, generateSchemablocks } from './prosemirror/blocks';\nexport { marks, generateSchemaMarks } from './prosemirror/marks';\nexport { placeholderPlugin, insertPlaceholder, replacePlaceholder } from './prosemirror/plugins/placeholder';\nexport { icons } from './prosemirror/icons';\nexport { keymap, baseKeymap, hardBreakKeymap } from './prosemirror/keymaps';\nexport * as menu from './prosemirror/menu';\nexport { default as createSchema } from './prosemirror/schema';\nexport { default as ExEditorView } from './ExEditorView';\n\n/**\n * @type {NodeListOf<HTMLElement>} proseInstances\n */\nconst proseInstances = document.querySelectorAll('.ex-prosemirror');\n\n/**\n * ExProsemirror manage prosemirror in elixir project.\n */\nclass ExProsemirror {\n  /**\n   * @param {[Object]} blocks\n   */\n  setBlocks(blocks) {\n    this.blocks = blocks;\n    return this;\n  }\n\n  /**\n   * @param {[Object]} marks\n   */\n  setMarks(marks) {\n    this.marks = marks;\n    return this;\n  }\n\n  setPlugins(plugins) {\n    this.plugins = plugins;\n    return this;\n  }\n\n  /**\n   * Initializes all prosemirror instances.\n   */\n  initAll() {\n    Array.from(proseInstances).forEach(el => {\n      this.init(el);\n    });\n  }\n\n  /**\n   * Initializes the specified target (should be an ex_prosemirror instance).\n   *\n   * @param {Element} target - target to initialize.\n   */\n  init(target) {\n    if (target instanceof HTMLElement) {\n      target.innerHTML = '';\n      const plugins = this.plugins || [];\n      return new ExEditorView(target, { blocks: this.blocks, marks: this.marks, plugins });\n    }\n\n    return null;\n  }\n}\n\nexport default new ExProsemirror();\n"],
  "mappings": "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",
  "names": []
}
